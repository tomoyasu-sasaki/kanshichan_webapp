# KanshiChan - コメント規約
# =============================================
# 対象: 全言語（Python, TypeScript, JavaScript, YAML, JSON）
# 概要: 統一されたコメント・ドキュメンテーション基準
# 参照: coding_rules.yaml, main_rules.yaml

# ===========================================
# 1. 基本原則
# ===========================================
basic_principles:
  purpose:
    clarity: "コードの意図と目的を明確に説明"
    maintainability: "将来の保守性向上"
    knowledge_sharing: "チーム内での知識共有"
    
  quality_guidelines:
    accuracy: "コードと常に同期した正確な内容"
    conciseness: "簡潔で要点を絞った説明"
    usefulness: "読み手にとって価値のある情報"
    
  when_to_comment:
    必須:
      - "複雑なアルゴリズムやロジック"
      - "なぜそのような実装になったかの理由"
      - "外部依存や前提条件"
      - "パフォーマンス上の考慮事項"
      - "セキュリティ上の注意点"
      - "将来的な改善点や制約"
    避けるべき:
      - "コードを読めば分かる自明な内容"
      - "古い情報や不正確な内容"
      - "TODO コメントの放置"

# ===========================================
# 2. Python コメント規約
# ===========================================
python:
  docstrings:
    format: "Google Style"
    required_for:
      - "全ての public クラス"
      - "全ての public メソッド・関数"
      - "複雑な private メソッド"
      - "モジュールレベル（__init__.py含む）"
      
    structure:
      summary: "1行での簡潔な要約"
      description: "詳細な説明（必要に応じて）"
      args: "引数の説明（型と内容）"
      returns: "戻り値の説明（型と内容）"
      raises: "発生する可能性のある例外"
      examples: "使用例（複雑な場合）"
      notes: "重要な注意事項"
      
  inline_comments:
    style: "# 単一行コメント"
    position: "コード行の上に配置（右側は避ける）"
    language: "日本語可（チーム内理解向上のため）"
    
  examples:
    module_docstring: |
      """カメラ管理モジュール
      
      Webカメラからの映像取得と前処理を行うモジュールです。
      OpenCVを使用してカメラデバイスを制御し、AI検出用の
      フレーム前処理を実行します。
      
      Typical usage example:
          camera = CameraManager()
          camera.start()
          frame = camera.get_frame()
      """
      
    class_docstring: |
      class ObjectDetector:
          """物体検出を行うメインクラス
          
          YOLOv8とMediaPipeを組み合わせて、リアルタイムでの
          人物とスマートフォンの検出を行います。
          
          Attributes:
              model_path: YOLOモデルファイルのパス
              confidence_threshold: 検出信頼度の閾値
              device: 推論デバイス（'cpu' または 'cuda'）
          """
          
    method_docstring: |
      def detect_objects(self, frame: np.ndarray) -> Dict[str, Any]:
          """フレーム内の物体を検出します
          
          入力されたフレームに対してYOLOv8による物体検出を実行し、
          検出結果をバウンディングボックスと信頼度と共に返します。
          
          Args:
              frame: 検出対象の画像フレーム。BGR形式のnumpy配列。
                     shape は (height, width, 3) である必要があります。
                     
          Returns:
              検出結果を含む辞書:
              {
                  'detections': List[Dict] - 検出されたオブジェクトのリスト
                  'count': int - 検出数
                  'processing_time': float - 処理時間（秒）
              }
              
          Raises:
              ValueError: フレームが None または空の場合
              RuntimeError: モデルが初期化されていない場合
              
          Examples:
              >>> detector = ObjectDetector()
              >>> frame = cv2.imread('test.jpg')
              >>> results = detector.detect_objects(frame)
              >>> print(f"検出数: {results['count']}")
          """
          
    inline_comment: |
      # GPU メモリ不足の場合はCPUにフォールバック
      try:
          results = self.model(frame)
      except torch.cuda.OutOfMemoryError:
          logger.warning("GPU memory insufficient, switching to CPU")
          self.model.to('cpu')
          results = self.model(frame)
          
      # MediaPipe の結果をYOLO形式に変換
      # NOTE: 座標系が異なるため変換が必要
      converted_results = self._convert_mediapipe_to_yolo(mp_results)

# ===========================================
# 3. TypeScript/JavaScript コメント規約
# ===========================================
typescript:
  jsdoc:
    format: "JSDoc 3.x"
    required_for:
      - "全ての exported 関数・クラス"
      - "複雑な interfaces・types"
      - "カスタムフック"
      - "ユーティリティ関数"
      
    structure:
      description: "概要説明"
      param: "パラメータの説明"
      returns: "戻り値の説明"
      throws: "例外の説明"
      example: "使用例"
      since: "バージョン情報（必要に応じて）"
      
  inline_comments:
    style: "// 単一行コメント または /* ブロックコメント */"
    position: "関連するコードの上に配置"
    language: "日本語可"
    
  examples:
    interface_comment: |
      /**
       * 検出状態を表すインターフェース
       * 
       * AIによる検出結果の状態と時間情報を含みます。
       * WebSocket経由でリアルタイムに更新されます。
       */
      interface DetectionStatus {
        /** 人物が検出されているかどうか */
        personDetected: boolean;
        /** スマートフォンが検出されているかどうか */
        smartphoneDetected: boolean;
        /** 不在時間（秒） */
        absenceTime: number;
        /** スマートフォン使用時間（秒） */
        smartphoneUseTime: number;
        /** 最終更新時刻 */
        lastUpdate: Date;
      }
      
    function_comment: |
      /**
       * WebSocket接続を管理するカスタムフック
       * 
       * バックエンドとのWebSocket接続を確立し、検出状態の
       * リアルタイム更新を提供します。接続エラー時の
       * 自動再接続機能も含みます。
       * 
       * @returns WebSocket の状態と制御関数
       * @example
       * ```tsx
       * const { status, isConnected, error, reconnect } = useWebSocket();
       * 
       * if (error) {
       *   console.error('WebSocket error:', error);
       *   reconnect();
       * }
       * ```
       */
      export const useWebSocket = (): UseWebSocketResult => {
        // Implementation
      };
      
    component_comment: |
      /**
       * メイン監視画面コンポーネント
       * 
       * カメラ映像の表示と検出状態の可視化を行います。
       * フルスクリーン表示とリアルタイム状態更新に対応。
       * 
       * @param props - コンポーネントのプロパティ
       * @param props.status - 現在の検出状態
       * @param props.isFullscreen - フルスクリーン表示フラグ
       * @param props.onToggleFullscreen - フルスクリーン切り替えハンドラ
       * @param props.onStatusChange - 状態変更時のコールバック
       */
      export const MonitorView: React.FC<MonitorViewProps> = ({
        status,
        isFullscreen = false,
        onToggleFullscreen,
        onStatusChange
      }) => {
        // コンポーネントロジック
      };
      
    inline_comment: |
      // Chakra UI のテーマ設定を上書き
      const customTheme = extendTheme({
        colors: {
          brand: {
            500: '#319795', // メインカラー
          }
        }
      });
      
      /* 
       * FIXME: パフォーマンス改善が必要
       * 現在の実装では毎回新しいオブジェクトを生成しており、
       * 不要な再レンダリングが発生する可能性があります。
       * useMemo での最適化を検討してください。
       */
      const expensiveCalculation = useMemo(() => {
        return someComplexCalculation(data);
      }, [data]);

# ===========================================
# 4. YAML コメント規約
# ===========================================
yaml:
  comment_style: "# ハッシュ記号"
  
  organization:
    section_headers: "主要セクションの説明"
    inline_explanations: "複雑な設定項目の説明"
    examples: "設定例の提供"
    
  examples:
    config_file: |
      # ===========================================
      # 物体検出設定
      # ===========================================
      detector:
        # MediaPipe を使用するかどうか
        # 姿勢検出とハンドトラッキングに使用
        use_mediapipe: true
        
        # YOLO を使用するかどうか  
        # スマートフォン検出に使用
        use_yolo: true
        
        mediapipe_options:
          pose:
            # 検出信頼度の閾値 (0.0-1.0)
            # 低い値ほど検出しやすいが誤検出も増加
            min_detection_confidence: 0.5
            
      # ===========================================
      # アラート設定
      # ===========================================
      alerts:
        enabled: true
        
        # アラート発火までの遅延時間（秒）
        # 誤検出によるアラートを防ぐための猶予時間
        delay_seconds: 30
        
        line_notify:
          enabled: false
          token: ""  # 環境変数 LINE_NOTIFY_TOKEN で設定

# ===========================================
# 5. 特殊なコメント規約
# ===========================================
special_comments:
  todo_comments:
    format: "TODO: 説明 (担当者名, 期限)"
    examples:
      - "TODO: エラーハンドリングの改善 (田中, 2024-12-15)"
      - "TODO: パフォーマンス最適化が必要 (佐藤, 次回リリース)"
      
  fixme_comments:
    format: "FIXME: 問題の説明 (優先度)"
    examples:
      - "FIXME: メモリリークの可能性 (高優先度)"
      - "FIXME: 型安全性の問題 (中優先度)"
      
  note_comments:
    format: "NOTE: 重要な注意事項"
    examples:
      - "NOTE: この関数はスレッドセーフではありません"
      - "NOTE: Python 3.9以上が必要"
      
  hack_comments:
    format: "HACK: 一時的な対処法の説明"
    examples:
      - "HACK: ライブラリのバグ回避のための暫定処理"

# ===========================================
# 6. コメントメンテナンス規約
# ===========================================
maintenance:
  update_policy:
    code_changes: "コード変更時はコメントも必ず更新"
    review_process: "コードレビューでコメントの適切性も確認"
    outdated_removal: "古いコメントは積極的に削除"
    
  quality_check:
    accuracy: "コメントとコードの一致確認"
    language: "文法・スペルチェック"
    usefulness: "コメントの価値評価"
    
  automation:
    doc_generation: "docstring からのドキュメント自動生成"
    link_validation: "外部リンクの有効性チェック"
    todo_tracking: "TODOコメントの追跡管理"

# ===========================================
# 7. ドキュメンテーション規約
# ===========================================
documentation:
  api_docs:
    auto_generation: "コメントからの自動生成"
    format: "Sphinx (Python), TypeDoc (TypeScript)"
    update_frequency: "リリース前に必ず更新"
    
  readme_files:
    structure:
      - "概要・目的"
      - "インストール方法"
      - "使用方法・例"
      - "設定項目"
      - "トラブルシューティング"
      
  changelog:
    format: "Keep a Changelog 形式"
    language: "日本語"
    detail_level: "ユーザー影響のある変更を明記"

# ===========================================
# 8. 多言語対応
# ===========================================
internationalization:
  primary_language: "日本語"
  fallback_language: "英語"
  
  guidelines:
    user_facing: "ユーザー向けメッセージは日本語"
    technical: "技術的な説明は英語でも可"
    consistency: "同一ファイル内では言語を統一"

# ===========================================
# 9. ツールとの連携
# ===========================================
tooling:
  linters:
    python: "pydocstyle での docstring チェック"
    typescript: "ESLint での JSDoc チェック"
    
  editors:
    vscode: "コメント補完拡張機能の活用"
    snippets: "コメントテンプレートの作成"
    
  ci_cd:
    doc_validation: "ドキュメント生成の自動検証"
    comment_coverage: "コメント網羅率の計測"

# ===========================================
# 10. 品質指標
# ===========================================
quality_metrics:
  coverage:
    target: "public API の 90% 以上"
    measurement: "自動化ツールでの計測"
    
  review_criteria:
    completeness: "必要な情報の網羅性"
    clarity: "理解しやすさ"
    correctness: "正確性"
    consistency: "プロジェクト内での一貫性" 