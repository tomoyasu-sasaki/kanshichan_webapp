=  ğŸ¯ ç›£è¦–ã¡ã‚ƒã‚“(KanshiChan) ç›£è¦–ã‚³ã‚¢æ©Ÿèƒ½è¨­è¨ˆ
:toc: left
:toc-title: ç›®æ¬¡
:toclevels: 4
:numbered:
:source-highlighter: highlight.js
:icons: font
:doctype: book
:version: 1.0.0
:author: KanshiChan Development Team
:email: team@kanshichan.dev
:revnumber: 1.0
:revdate: {docdate}
:experimental:

== ğŸ“– æ¦‚è¦

ç›£è¦–ã¡ã‚ƒã‚“ï¼ˆKanshiChanï¼‰ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ã®ç›£è¦–ã‚³ã‚¢æ©Ÿèƒ½è©³ç´°è¨­è¨ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã™ã€‚
ç›£è¦–ãƒ«ãƒ¼ãƒ—ã€çŠ¶æ…‹ç®¡ç†ã€ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½ã€ãƒ‡ãƒ¼ã‚¿åé›†æ©Ÿèƒ½ã®å®Ÿè£…è©³ç´°ã¨é‹ç”¨æ‰‹é †ã‚’åŒ…æ‹¬çš„ã«èª¬æ˜ã—ã¾ã™ã€‚

[NOTE]
====
ğŸ“‹ **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæƒ…å ±**

* **å¯¾è±¡èª­è€…**: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºè€…ã€ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã€ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ æ‹…å½“è€…
* **å‰æçŸ¥è­˜**: Python/Flaskã€Redisã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ»ãƒ—ãƒ­ã‚»ã‚¹ç®¡ç†
* **ç›£è¦–æ€§èƒ½ç›®æ¨™**: ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç† 15FPSã€æ¤œå‡ºé…å»¶ < 100msã€çŠ¶æ…‹æ›´æ–° < 10ms
* **å¯ç”¨æ€§ç›®æ¨™**: 99.9%ã€ç›£è¦–ãƒ«ãƒ¼ãƒ—å¾©æ—§æ™‚é–“ < 30ç§’
* **æœ€çµ‚æ›´æ–°**: {docdate}

**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: <<system-design>>, <<detection-system>>, <<performance-optimization>>
====

== ğŸ¯ ç›£è¦–ã‚³ã‚¢æ©Ÿèƒ½ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

=== ğŸ—ï¸ å…¨ä½“æ§‹æˆ

[mermaid]
....
graph TB
    subgraph "ğŸ¯ Monitoring Core"
        MONITOR[Monitor Controller<br/>ç›£è¦–åˆ¶å¾¡]
        LOOP[Monitoring Loop<br/>ç›£è¦–ãƒ«ãƒ¼ãƒ—]
        STATE[State Manager<br/>çŠ¶æ…‹ç®¡ç†]
        ALERT[Alert Manager<br/>ã‚¢ãƒ©ãƒ¼ãƒˆç®¡ç†]
    end
    
    subgraph "ğŸ” Detection Engine"
        CAMERA[Camera Manager<br/>ã‚«ãƒ¡ãƒ©ç®¡ç†]
        FRAME_PROC[Frame Processor<br/>ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†]
        AI_DETECT[AI Detector<br/>AIæ¤œå‡ºã‚¨ãƒ³ã‚¸ãƒ³]
        RESULT_PROC[Result Processor<br/>çµæœå‡¦ç†]
    end
    
    subgraph "ğŸ’¾ Data Management"
        REDIS_STORE[Redis Storage<br/>ãƒ‡ãƒ¼ã‚¿ä¿å­˜]
        CACHE_MGR[Cache Manager<br/>ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†]
        SESSION_MGR[Session Manager<br/>ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†]
        PERF_MONITOR[Performance Monitor<br/>æ€§èƒ½ç›£è¦–]
    end
    
    subgraph "ğŸ“¡ Communication"
        WS_BROADCAST[WebSocket Broadcaster<br/>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é…ä¿¡]
        API_HANDLER[API Handler<br/>APIå‡¦ç†]
        EVENT_EMITTER[Event Emitter<br/>ã‚¤ãƒ™ãƒ³ãƒˆé€ä¿¡]
        LOGGER[Logger<br/>ãƒ­ã‚°å‡ºåŠ›]
    end
    
    subgraph "âš™ï¸ Configuration"
        CONFIG_MGR[Config Manager<br/>è¨­å®šç®¡ç†]
        SCHEDULE_MGR[Schedule Manager<br/>ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†]
        RESOURCE_MGR[Resource Manager<br/>ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†]
    end
    
    %% Core flow
    MONITOR --> LOOP
    LOOP --> STATE
    STATE --> ALERT
    
    %% Detection flow
    CAMERA --> FRAME_PROC
    FRAME_PROC --> AI_DETECT
    AI_DETECT --> RESULT_PROC
    RESULT_PROC --> STATE
    
    %% Data flow
    STATE --> REDIS_STORE
    ALERT --> CACHE_MGR
    LOOP --> SESSION_MGR
    MONITOR --> PERF_MONITOR
    
    %% Communication flow
    STATE --> WS_BROADCAST
    ALERT --> EVENT_EMITTER
    MONITOR --> API_HANDLER
    LOOP --> LOGGER
    
    %% Configuration flow
    CONFIG_MGR --> MONITOR
    SCHEDULE_MGR --> LOOP
    RESOURCE_MGR --> CAMERA
    
    classDef core fill:#e3f2fd
    classDef detection fill:#e8f5e8
    classDef data fill:#fff3e0
    classDef communication fill:#f3e5f5
    classDef config fill:#fce4ec
    
    class MONITOR,LOOP,STATE,ALERT core
    class CAMERA,FRAME_PROC,AI_DETECT,RESULT_PROC detection
    class REDIS_STORE,CACHE_MGR,SESSION_MGR,PERF_MONITOR data
    class WS_BROADCAST,API_HANDLER,EVENT_EMITTER,LOGGER communication
    class CONFIG_MGR,SCHEDULE_MGR,RESOURCE_MGR config
....

=== ğŸ“Š ç›£è¦–ã‚³ã‚¢æ©Ÿèƒ½æ¦‚è¦

[cols="2,2,2,2", options="header"]
|===
|æ©Ÿèƒ½åˆ†é¡ |ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ |è²¬å‹™ |ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™
|**ç›£è¦–åˆ¶å¾¡** |Monitor Controller |ç›£è¦–ã®é–‹å§‹ãƒ»åœæ­¢ãƒ»åˆ¶å¾¡ |èµ·å‹•æ™‚é–“ < 10ç§’
|**ç›£è¦–ãƒ«ãƒ¼ãƒ—** |Monitoring Loop |é€£ç¶šçš„ãªç›£è¦–å‡¦ç†å®Ÿè¡Œ |å‡¦ç†é »åº¦ 15-30 FPS
|**çŠ¶æ…‹ç®¡ç†** |State Manager |ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®ç®¡ç†ãƒ»æ›´æ–° |çŠ¶æ…‹æ›´æ–° < 10ms
|**ã‚¢ãƒ©ãƒ¼ãƒˆç®¡ç†** |Alert Manager |æ¡ä»¶åˆ¤å®šãƒ»é€šçŸ¥å®Ÿè¡Œ |ã‚¢ãƒ©ãƒ¼ãƒˆé…å»¶ < 1ç§’
|===

== ğŸ”„ ç›£è¦–ãƒ«ãƒ¼ãƒ—è©³ç´°è¨­è¨ˆ

=== âš¡ ãƒ¡ã‚¤ãƒ³ç›£è¦–ãƒ«ãƒ¼ãƒ—ãƒ•ãƒ­ãƒ¼

[mermaid]
....
flowchart TD
    START([ç›£è¦–é–‹å§‹])
    
    %% åˆæœŸåŒ–ãƒ•ã‚§ãƒ¼ã‚º
    INIT_CHECK{åˆæœŸåŒ–å®Œäº†?}
    INIT_SYSTEM[ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–]
    INIT_CAMERA[ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–]
    INIT_AI[AI ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–]
    
    %% ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
    LOOP_START{ç›£è¦–ç¶™ç¶š?}
    FRAME_CAPTURE[ãƒ•ãƒ¬ãƒ¼ãƒ å–å¾—]
    FRAME_VALID{ãƒ•ãƒ¬ãƒ¼ãƒ æœ‰åŠ¹?}
    
    %% å‡¦ç†åˆ¤å®š
    SCHEDULE_CHECK{ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç¢ºèª}
    PROCESSING_LOAD{å‡¦ç†è² è·ç¢ºèª}
    SKIP_FRAME[ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¹ã‚­ãƒƒãƒ—]
    
    %% AIå‡¦ç†
    AI_PROCESSING[AIæ¤œå‡ºå‡¦ç†]
    RESULT_VALIDATE{çµæœæ¤œè¨¼}
    RESULT_PROCESS[çµæœå‡¦ç†]
    
    %% çŠ¶æ…‹ç®¡ç†
    STATE_UPDATE[çŠ¶æ…‹æ›´æ–°]
    ALERT_CHECK{ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶?}
    TRIGGER_ALERT[ã‚¢ãƒ©ãƒ¼ãƒˆç™ºå‹•]
    
    %% ãƒ‡ãƒ¼ã‚¿ç®¡ç†
    DATA_STORE[ãƒ‡ãƒ¼ã‚¿ä¿å­˜]
    CACHE_UPDATE[ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°]
    BROADCAST[çŠ¶æ…‹é…ä¿¡]
    
    %% ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç®¡ç†
    PERF_CHECK{æ€§èƒ½ç›£è¦–}
    MEMORY_CHECK{ãƒ¡ãƒ¢ãƒªç¢ºèª}
    RESOURCE_CLEANUP[ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—]
    
    %% ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    ERROR_HANDLE[ã‚¨ãƒ©ãƒ¼å‡¦ç†]
    RECOVERY[å¾©æ—§å‡¦ç†]
    
    STOP[ç›£è¦–åœæ­¢]
    CLEANUP[æœ€çµ‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—]
    END([çµ‚äº†])
    
    %% ãƒ•ãƒ­ãƒ¼æ¥ç¶š
    START --> INIT_CHECK
    INIT_CHECK -->|No| INIT_SYSTEM
    INIT_CHECK -->|Yes| LOOP_START
    
    INIT_SYSTEM --> INIT_CAMERA
    INIT_CAMERA --> INIT_AI
    INIT_AI --> INIT_CHECK
    
    LOOP_START -->|Yes| FRAME_CAPTURE
    LOOP_START -->|No| STOP
    
    FRAME_CAPTURE --> FRAME_VALID
    FRAME_VALID -->|Valid| SCHEDULE_CHECK
    FRAME_VALID -->|Invalid| ERROR_HANDLE
    
    SCHEDULE_CHECK -->|Active| PROCESSING_LOAD
    SCHEDULE_CHECK -->|Inactive| LOOP_START
    
    PROCESSING_LOAD -->|Normal| AI_PROCESSING
    PROCESSING_LOAD -->|High| SKIP_FRAME
    SKIP_FRAME --> LOOP_START
    
    AI_PROCESSING --> RESULT_VALIDATE
    RESULT_VALIDATE -->|Valid| RESULT_PROCESS
    RESULT_VALIDATE -->|Invalid| ERROR_HANDLE
    
    RESULT_PROCESS --> STATE_UPDATE
    STATE_UPDATE --> ALERT_CHECK
    
    ALERT_CHECK -->|Yes| TRIGGER_ALERT
    ALERT_CHECK -->|No| DATA_STORE
    TRIGGER_ALERT --> DATA_STORE
    
    DATA_STORE --> CACHE_UPDATE
    CACHE_UPDATE --> BROADCAST
    BROADCAST --> PERF_CHECK
    
    PERF_CHECK -->|Normal| LOOP_START
    PERF_CHECK -->|Issue| MEMORY_CHECK
    
    MEMORY_CHECK -->|OK| LOOP_START
    MEMORY_CHECK -->|Critical| RESOURCE_CLEANUP
    RESOURCE_CLEANUP --> LOOP_START
    
    ERROR_HANDLE --> RECOVERY
    RECOVERY --> LOOP_START
    
    STOP --> CLEANUP
    CLEANUP --> END
    
    classDef start fill:#e8f5e8
    classDef process fill:#e3f2fd
    classDef decision fill:#fff3e0
    classDef error fill:#ffebee
    classDef end fill:#f3e5f5
    
    class START,END start
    class INIT_SYSTEM,AI_PROCESSING,STATE_UPDATE,DATA_STORE process
    class INIT_CHECK,FRAME_VALID,SCHEDULE_CHECK,ALERT_CHECK decision
    class ERROR_HANDLE,RECOVERY error
    class STOP,CLEANUP end
....

=== ğŸ”§ ç›£è¦–ãƒ«ãƒ¼ãƒ—å®Ÿè£…è©³ç´°

```python
# Core monitoring loop implementation
class MonitoringLoop:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.is_running = False
        self.loop_stats = LoopStatistics()
        self.error_handler = ErrorHandler()
        
        # ç›£è¦–ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
        self.camera_manager = CameraManager(config_manager)
        self.frame_processor = FrameProcessor(config_manager)
        self.ai_detector = AIDetector(config_manager)
        self.state_manager = StateManager(config_manager)
        self.alert_manager = AlertManager(config_manager)
        
        # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
        self.performance_monitor = PerformanceMonitor()
        self.resource_manager = ResourceManager()
        
    async def start_monitoring(self):
        """ç›£è¦–ãƒ«ãƒ¼ãƒ—ã®é–‹å§‹"""
        try:
            await self._initialize_system()
            self.is_running = True
            
            logger.info("Monitoring loop started")
            await self._main_monitoring_loop()
            
        except Exception as e:
            self.error_handler.handle_critical_error(e)
            raise
        finally:
            await self._cleanup_system()
    
    async def _main_monitoring_loop(self):
        """ãƒ¡ã‚¤ãƒ³ç›£è¦–ãƒ«ãƒ¼ãƒ—"""
        while self.is_running:
            loop_start_time = time.time()
            
            try:
                # ãƒ•ãƒ¬ãƒ¼ãƒ å–å¾—
                frame = await self.camera_manager.capture_frame()
                if frame is None:
                    continue
                
                # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç¢ºèª
                if not self._is_monitoring_active():
                    await asyncio.sleep(1.0)
                    continue
                
                # å‡¦ç†è² è·ç¢ºèª
                if self._should_skip_frame():
                    self.loop_stats.increment_skipped_frames()
                    continue
                
                # AIæ¤œå‡ºå‡¦ç†
                detection_result = await self._process_frame(frame)
                
                # çŠ¶æ…‹æ›´æ–°ã¨ã‚¢ãƒ©ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
                await self._update_system_state(detection_result)
                
                # ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã¨é…ä¿¡
                await self._store_and_broadcast(detection_result)
                
                # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
                await self._monitor_performance(loop_start_time)
                
            except Exception as e:
                await self.error_handler.handle_loop_error(e)
                await asyncio.sleep(0.1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—å¾…æ©Ÿ
    
    async def _process_frame(self, frame: np.ndarray) -> DetectionResult:
        """ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†"""
        try:
            # ãƒ•ãƒ¬ãƒ¼ãƒ å‰å‡¦ç†
            processed_frame = await self.frame_processor.preprocess(frame)
            
            # AIæ¤œå‡ºå®Ÿè¡Œ
            detection_result = await self.ai_detector.detect(processed_frame)
            
            # çµæœæ¤œè¨¼
            if not self._validate_detection_result(detection_result):
                raise ValidationError("Invalid detection result")
            
            return detection_result
            
        except Exception as e:
            self.error_handler.handle_processing_error(e)
            return DetectionResult.empty()
    
    async def _update_system_state(self, detection_result: DetectionResult):
        """ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹æ›´æ–°"""
        # çŠ¶æ…‹ç®¡ç†æ›´æ–°
        state_changed = await self.state_manager.update_state(detection_result)
        
        # ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶ãƒã‚§ãƒƒã‚¯
        if state_changed:
            await self.alert_manager.check_alert_conditions(
                self.state_manager.get_current_state()
            )
    
    def _is_monitoring_active(self) -> bool:
        """ç›£è¦–ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åˆ¤å®š"""
        current_schedule = self.config.schedule_manager.get_current_schedule()
        return current_schedule and current_schedule.monitoring_enabled
    
    def _should_skip_frame(self) -> bool:
        """ãƒ•ãƒ¬ãƒ¼ãƒ ã‚¹ã‚­ãƒƒãƒ—åˆ¤å®š"""
        # CPU/GPUä½¿ç”¨ç‡ç¢ºèª
        cpu_usage = self.performance_monitor.get_cpu_usage()
        memory_usage = self.performance_monitor.get_memory_usage()
        
        # è² è·ãŒé«˜ã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
        if cpu_usage > 80 or memory_usage > 85:
            return True
        
        # é©å¿œçš„ã‚¹ã‚­ãƒƒãƒ—ï¼ˆFPSèª¿æ•´ï¼‰
        current_fps = self.loop_stats.get_current_fps()
        target_fps = self.config.get_target_fps()
        
        return current_fps > target_fps * 1.2
```

== ğŸ›ï¸ çŠ¶æ…‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

=== ğŸ“Š çŠ¶æ…‹ç®¡ç†ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

[mermaid]
....
stateDiagram-v2
    [*] --> INITIALIZING
    INITIALIZING --> PRESENT : äººæ¤œå‡º
    INITIALIZING --> ABSENT : äººæœªæ¤œå‡º
    INITIALIZING --> UNKNOWN : åˆ¤å®šä¸èƒ½
    
    PRESENT --> ABSENT : ä¸åœ¨æ¤œå‡º
    PRESENT --> SMARTPHONE_DETECTED : ã‚¹ãƒãƒ›æ¤œå‡º
    PRESENT --> PRESENT : äººç¶™ç¶šæ¤œå‡º
    
    ABSENT --> PRESENT : äººæ¤œå‡º
    ABSENT --> ABSENT : ä¸åœ¨ç¶™ç¶š
    
    SMARTPHONE_DETECTED --> PRESENT : ã‚¹ãƒãƒ›æœªæ¤œå‡º
    SMARTPHONE_DETECTED --> ABSENT : äººæœªæ¤œå‡º
    SMARTPHONE_DETECTED --> SMARTPHONE_DETECTED : ã‚¹ãƒãƒ›ç¶™ç¶šä½¿ç”¨
    
    UNKNOWN --> PRESENT : äººæ¤œå‡º
    UNKNOWN --> ABSENT : ä¸åœ¨ç¢ºå®š
    UNKNOWN --> UNKNOWN : åˆ¤å®šä¸èƒ½ç¶™ç¶š
    
    PRESENT --> [*] : ã‚·ã‚¹ãƒ†ãƒ åœæ­¢
    ABSENT --> [*] : ã‚·ã‚¹ãƒ†ãƒ åœæ­¢
    SMARTPHONE_DETECTED --> [*] : ã‚·ã‚¹ãƒ†ãƒ åœæ­¢
    UNKNOWN --> [*] : ã‚·ã‚¹ãƒ†ãƒ åœæ­¢
....

=== ğŸ”„ çŠ¶æ…‹é·ç§»ç®¡ç†

```python
# State management implementation
class StateManager:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.current_state = MonitoringState.INITIALIZING
        self.previous_state = None
        self.state_history = []
        
        # ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†
        self.absence_start_time = None
        self.smartphone_start_time = None
        self.state_change_time = time.time()
        
        # çµ±è¨ˆæƒ…å ±
        self.state_statistics = StateStatistics()
        
    async def update_state(self, detection_result: DetectionResult) -> bool:
        """çŠ¶æ…‹æ›´æ–°"""
        new_state = self._determine_new_state(detection_result)
        
        if new_state != self.current_state:
            await self._transition_state(new_state, detection_result)
            return True
        else:
            self._update_state_timers(detection_result)
            return False
    
    def _determine_new_state(self, detection_result: DetectionResult) -> MonitoringState:
        """æ–°ã—ã„çŠ¶æ…‹ã®æ±ºå®š"""
        # ä¿¡é ¼åº¦ãƒã‚§ãƒƒã‚¯
        if not self._is_reliable_detection(detection_result):
            return self.current_state  # ä¿¡é ¼åº¦ãŒä½ã„å ´åˆã¯çŠ¶æ…‹å¤‰æ›´ã—ãªã„
        
        # çŠ¶æ…‹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
        if detection_result.person_detected:
            if detection_result.smartphone_detected:
                return MonitoringState.SMARTPHONE_DETECTED
            else:
                return MonitoringState.PRESENT
        else:
            return MonitoringState.ABSENT
    
    async def _transition_state(self, new_state: MonitoringState, detection_result: DetectionResult):
        """çŠ¶æ…‹é·ç§»å‡¦ç†"""
        old_state = self.current_state
        transition_time = time.time()
        
        # çŠ¶æ…‹é·ç§»è¨˜éŒ²
        transition = StateTransition(
            from_state=old_state,
            to_state=new_state,
            timestamp=transition_time,
            trigger="detection_result",
            confidence=detection_result.get_max_confidence(),
            context=detection_result.to_dict()
        )
        
        # çŠ¶æ…‹æ›´æ–°
        self.previous_state = old_state
        self.current_state = new_state
        self.state_change_time = transition_time
        
        # ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†
        self._manage_state_timers(new_state, transition_time)
        
        # å±¥æ­´è¨˜éŒ²
        self.state_history.append(transition)
        self._trim_history()
        
        # çµ±è¨ˆæ›´æ–°
        self.state_statistics.record_transition(transition)
        
        # çŠ¶æ…‹é·ç§»ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿ
        await self._emit_state_change_event(transition)
        
        logger.info(f"State transition: {old_state.name} -> {new_state.name}")
    
    def _manage_state_timers(self, new_state: MonitoringState, timestamp: float):
        """çŠ¶æ…‹ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†"""
        if new_state == MonitoringState.ABSENT:
            if self.absence_start_time is None:
                self.absence_start_time = timestamp
        else:
            self.absence_start_time = None
        
        if new_state == MonitoringState.SMARTPHONE_DETECTED:
            if self.smartphone_start_time is None:
                self.smartphone_start_time = timestamp
        else:
            self.smartphone_start_time = None
    
    def get_absence_duration(self) -> int:
        """ä¸åœ¨æ™‚é–“ã®å–å¾—"""
        if self.absence_start_time is None:
            return 0
        return int(time.time() - self.absence_start_time)
    
    def get_smartphone_usage_duration(self) -> int:
        """ã‚¹ãƒãƒ›ä½¿ç”¨æ™‚é–“ã®å–å¾—"""
        if self.smartphone_start_time is None:
            return 0
        return int(time.time() - self.smartphone_start_time)
    
    def _is_reliable_detection(self, detection_result: DetectionResult) -> bool:
        """æ¤œå‡ºçµæœã®ä¿¡é ¼åº¦åˆ¤å®š"""
        min_confidence = self.config.get_min_confidence_threshold()
        
        # äººæ¤œå‡ºã®ä¿¡é ¼åº¦
        if detection_result.person_detected:
            if detection_result.person_confidence < min_confidence:
                return False
        
        # ã‚¹ãƒãƒ›æ¤œå‡ºã®ä¿¡é ¼åº¦
        if detection_result.smartphone_detected:
            if detection_result.smartphone_confidence < min_confidence:
                return False
        
        return True
```

== ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

=== ğŸ“‹ ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

[mermaid]
....
graph TB
    subgraph "ğŸ” Detection & Triggers"
        CONDITION[Condition Evaluator<br/>æ¡ä»¶è©•ä¾¡]
        TIMER[Timer Manager<br/>ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†]
        PATTERN[Pattern Detector<br/>ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º]
        THRESHOLD[Threshold Monitor<br/>é–¾å€¤ç›£è¦–]
    end
    
    subgraph "âš™ï¸ Alert Processing"
        RULE_ENGINE[Rule Engine<br/>ãƒ«ãƒ¼ãƒ«ã‚¨ãƒ³ã‚¸ãƒ³]
        PRIORITY[Priority Manager<br/>å„ªå…ˆåº¦ç®¡ç†]
        THROTTLE[Throttling<br/>åˆ¶é™åˆ¶å¾¡]
        DEDUP[Deduplication<br/>é‡è¤‡æ’é™¤]
    end
    
    subgraph "ğŸ“¢ Notification Channels"
        TTS[TTS Notification<br/>éŸ³å£°é€šçŸ¥]
        SOUND[Sound Alert<br/>éŸ³å£°ã‚¢ãƒ©ãƒ¼ãƒˆ]
        WEBSOCKET[WebSocket<br/>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥]
        LINE_MSG[LINE Message<br/>LINEé€šçŸ¥]
        LOG[Log Output<br/>ãƒ­ã‚°å‡ºåŠ›]
    end
    
    subgraph "ğŸ“Š Alert Management"
        HISTORY[Alert History<br/>ã‚¢ãƒ©ãƒ¼ãƒˆå±¥æ­´]
        ANALYTICS[Alert Analytics<br/>åˆ†æ]
        CONFIG[Alert Config<br/>è¨­å®šç®¡ç†]
        TESTING[Testing Mode<br/>ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰]
    end
    
    %% Detection to Processing
    CONDITION --> RULE_ENGINE
    TIMER --> RULE_ENGINE
    PATTERN --> PRIORITY
    THRESHOLD --> THROTTLE
    
    %% Processing flow
    RULE_ENGINE --> PRIORITY
    PRIORITY --> THROTTLE
    THROTTLE --> DEDUP
    
    %% Notification dispatch
    DEDUP --> TTS
    DEDUP --> SOUND
    DEDUP --> WEBSOCKET
    DEDUP --> LINE_MSG
    DEDUP --> LOG
    
    %% Management
    RULE_ENGINE --> HISTORY
    PRIORITY --> ANALYTICS
    CONFIG --> RULE_ENGINE
    TESTING --> DEDUP
    
    classDef detection fill:#e3f2fd
    classDef processing fill:#e8f5e8
    classDef notification fill:#fff3e0
    classDef management fill:#f3e5f5
    
    class CONDITION,TIMER,PATTERN,THRESHOLD detection
    class RULE_ENGINE,PRIORITY,THROTTLE,DEDUP processing
    class TTS,SOUND,WEBSOCKET,LINE_MSG,LOG notification
    class HISTORY,ANALYTICS,CONFIG,TESTING management
....

=== ğŸ”” ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«å®šç¾©

```python
# Alert rules and conditions
class AlertRuleEngine:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.active_alerts = {}
        self.alert_history = []
        self.notification_throttle = NotificationThrottle()
        
        # ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«å®šç¾©
        self.rules = [
            AbsenceAlertRule(),
            SmartphoneUsageAlertRule(),
            SystemHealthAlertRule(),
            PerformanceAlertRule()
        ]
    
    async def evaluate_alerts(self, current_state: MonitoringState, 
                            state_manager: StateManager) -> List[Alert]:
        """ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶è©•ä¾¡"""
        triggered_alerts = []
        
        for rule in self.rules:
            if rule.is_enabled():
                alert = await rule.evaluate(current_state, state_manager)
                if alert:
                    # é‡è¤‡ãƒã‚§ãƒƒã‚¯
                    if not self._is_duplicate_alert(alert):
                        # åˆ¶é™ãƒã‚§ãƒƒã‚¯
                        if self.notification_throttle.can_send(alert):
                            triggered_alerts.append(alert)
                            await self._process_alert(alert)
        
        return triggered_alerts
    
    async def _process_alert(self, alert: Alert):
        """ã‚¢ãƒ©ãƒ¼ãƒˆå‡¦ç†"""
        # ã‚¢ãƒ©ãƒ¼ãƒˆè¨˜éŒ²
        self.active_alerts[alert.id] = alert
        self.alert_history.append(alert)
        
        # é€šçŸ¥é€ä¿¡
        await self._send_notifications(alert)
        
        # çµ±è¨ˆæ›´æ–°
        self._update_alert_statistics(alert)
        
        logger.warning(f"Alert triggered: {alert.type.name} - {alert.message}")

# Alert rule implementations
class AbsenceAlertRule(AlertRule):
    def __init__(self):
        super().__init__("absence_alert", AlertType.ABSENCE)
        self.absence_threshold = 300  # 5åˆ†
    
    async def evaluate(self, current_state: MonitoringState, 
                      state_manager: StateManager) -> Optional[Alert]:
        if current_state == MonitoringState.ABSENT:
            absence_duration = state_manager.get_absence_duration()
            
            if absence_duration >= self.absence_threshold:
                return Alert(
                    id=str(uuid.uuid4()),
                    type=AlertType.ABSENCE,
                    message=f"ä¸åœ¨ãŒ{absence_duration}ç§’ç¶™ç¶šã—ã¦ã„ã¾ã™",
                    severity=AlertSeverity.WARNING,
                    context={
                        "absence_duration": absence_duration,
                        "threshold": self.absence_threshold
                    }
                )
        return None

class SmartphoneUsageAlertRule(AlertRule):
    def __init__(self):
        super().__init__("smartphone_usage", AlertType.SMARTPHONE_USAGE)
        self.usage_threshold = 600  # 10åˆ†
    
    async def evaluate(self, current_state: MonitoringState, 
                      state_manager: StateManager) -> Optional[Alert]:
        if current_state == MonitoringState.SMARTPHONE_DETECTED:
            usage_duration = state_manager.get_smartphone_usage_duration()
            
            if usage_duration >= self.usage_threshold:
                return Alert(
                    id=str(uuid.uuid4()),
                    type=AlertType.SMARTPHONE_USAGE,
                    message=f"ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ä½¿ç”¨ãŒ{usage_duration}ç§’ç¶™ç¶šã—ã¦ã„ã¾ã™",
                    severity=AlertSeverity.INFO,
                    context={
                        "usage_duration": usage_duration,
                        "threshold": self.usage_threshold
                    }
                )
        return None
```

== ğŸ“Š ãƒ‡ãƒ¼ã‚¿åé›†ãƒ»ä¿å­˜æ©Ÿèƒ½

=== ğŸ’¾ ãƒ‡ãƒ¼ã‚¿åé›†æˆ¦ç•¥

[mermaid]
....
graph LR
    subgraph "ğŸ“¥ Data Sources"
        DETECTION[Detection Results<br/>æ¤œå‡ºçµæœ]
        STATE[State Changes<br/>çŠ¶æ…‹å¤‰æ›´]
        PERFORMANCE[Performance Metrics<br/>æ€§èƒ½ãƒ¡ãƒˆãƒªã‚¯ã‚¹]
        ALERTS[Alert Events<br/>ã‚¢ãƒ©ãƒ¼ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ]
        SYSTEM[System Health<br/>ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹]
    end
    
    subgraph "ğŸ”„ Processing Pipeline"
        VALIDATE[Data Validation<br/>ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼]
        TRANSFORM[Data Transform<br/>ãƒ‡ãƒ¼ã‚¿å¤‰æ›]
        ENRICH[Data Enrichment<br/>ãƒ‡ãƒ¼ã‚¿æ‹¡å¼µ]
        BATCH[Batch Processing<br/>ãƒãƒƒãƒå‡¦ç†]
    end
    
    subgraph "ğŸ’¾ Storage Layer"
        REDIS_REALTIME[Redis Real-time<br/>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿]
        REDIS_ANALYTICS[Redis Analytics<br/>åˆ†æãƒ‡ãƒ¼ã‚¿]
        FILE_STORAGE[File Storage<br/>ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜]
        BACKUP[Backup Storage<br/>ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—]
    end
    
    subgraph "ğŸ“Š Data Access"
        QUERY_API[Query API<br/>ã‚¯ã‚¨ãƒªAPI]
        AGGREGATION[Data Aggregation<br/>ãƒ‡ãƒ¼ã‚¿é›†ç´„]
        EXPORT[Data Export<br/>ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ]
        REPORTING[Reporting<br/>ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ]
    end
    
    %% Data flow
    DETECTION --> VALIDATE
    STATE --> VALIDATE
    PERFORMANCE --> TRANSFORM
    ALERTS --> ENRICH
    SYSTEM --> BATCH
    
    VALIDATE --> TRANSFORM
    TRANSFORM --> ENRICH
    ENRICH --> BATCH
    
    BATCH --> REDIS_REALTIME
    BATCH --> REDIS_ANALYTICS
    BATCH --> FILE_STORAGE
    REDIS_REALTIME --> BACKUP
    
    REDIS_REALTIME --> QUERY_API
    REDIS_ANALYTICS --> AGGREGATION
    FILE_STORAGE --> EXPORT
    BACKUP --> REPORTING
    
    classDef source fill:#e3f2fd
    classDef processing fill:#e8f5e8
    classDef storage fill:#fff3e0
    classDef access fill:#f3e5f5
    
    class DETECTION,STATE,PERFORMANCE,ALERTS,SYSTEM source
    class VALIDATE,TRANSFORM,ENRICH,BATCH processing
    class REDIS_REALTIME,REDIS_ANALYTICS,FILE_STORAGE,BACKUP storage
    class QUERY_API,AGGREGATION,EXPORT,REPORTING access
....

=== ğŸ—ƒï¸ ãƒ‡ãƒ¼ã‚¿åé›†å®Ÿè£…

```python
# Data collection implementation
class DataCollector:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.redis_client = RedisClient()
        self.data_validator = DataValidator()
        self.batch_processor = BatchProcessor()
        
        # ãƒ‡ãƒ¼ã‚¿åé›†çµ±è¨ˆ
        self.collection_stats = CollectionStatistics()
        
    async def collect_detection_data(self, detection_result: DetectionResult, 
                                   session_id: str):
        """æ¤œå‡ºãƒ‡ãƒ¼ã‚¿ã®åé›†"""
        try:
            # ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼
            if not self.data_validator.validate_detection_result(detection_result):
                raise ValidationError("Invalid detection result")
            
            # ãƒ‡ãƒ¼ã‚¿æ‹¡å¼µ
            enriched_data = self._enrich_detection_data(detection_result, session_id)
            
            # ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ä¿å­˜
            await self._store_realtime_data(enriched_data)
            
            # ãƒãƒƒãƒå‡¦ç†ç”¨ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
            await self.batch_processor.add_to_queue("detection", enriched_data)
            
            self.collection_stats.increment_detection_count()
            
        except Exception as e:
            logger.error(f"Failed to collect detection data: {e}")
            self.collection_stats.increment_error_count()
    
    async def collect_state_change(self, state_transition: StateTransition):
        """çŠ¶æ…‹å¤‰æ›´ãƒ‡ãƒ¼ã‚¿ã®åé›†"""
        try:
            # çŠ¶æ…‹å¤‰æ›´ãƒ‡ãƒ¼ã‚¿æ§‹ç¯‰
            state_data = {
                "transition_id": str(uuid.uuid4()),
                "timestamp": state_transition.timestamp,
                "from_state": state_transition.from_state.name,
                "to_state": state_transition.to_state.name,
                "trigger": state_transition.trigger,
                "confidence": state_transition.confidence,
                "duration": self._calculate_state_duration(state_transition),
                "context": state_transition.context
            }
            
            # ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ›´æ–°
            await self._update_behavior_timeline(state_data)
            
            # çµ±è¨ˆæ›´æ–°
            await self._update_behavior_statistics(state_data)
            
        except Exception as e:
            logger.error(f"Failed to collect state change: {e}")
    
    async def collect_performance_metrics(self, metrics: dict):
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†"""
        try:
            timestamp = time.time()
            metric_id = f"metrics:{int(timestamp)}"
            
            # ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿æ§‹ç¯‰
            metrics_data = {
                "metric_id": metric_id,
                "timestamp": timestamp,
                "instance_id": self.config.get_instance_id(),
                **metrics
            }
            
            # Redisä¿å­˜ï¼ˆçŸ­æœŸé–“ï¼‰
            await self.redis_client.setex(
                metric_id, 3600, json.dumps(metrics_data)
            )
            
            # æ™‚ç³»åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ›´æ–°
            await self.redis_client.zadd(
                f"metrics:index:instance:{self.config.get_instance_id()}",
                {metric_id: timestamp}
            )
            
        except Exception as e:
            logger.error(f"Failed to collect performance metrics: {e}")
    
    def _enrich_detection_data(self, detection_result: DetectionResult, 
                              session_id: str) -> dict:
        """æ¤œå‡ºãƒ‡ãƒ¼ã‚¿ã®æ‹¡å¼µ"""
        return {
            "detection_id": str(uuid.uuid4()),
            "session_id": session_id,
            "timestamp": time.time(),
            "instance_id": self.config.get_instance_id(),
            **detection_result.to_dict(),
            "enriched_metadata": {
                "processing_node": self.config.get_node_id(),
                "model_versions": self._get_model_versions(),
                "system_state": self._get_system_state()
            }
        }
```

== ğŸ”— é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

=== ğŸ“– å¿…é ˆå‚ç…§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
* **<<system-design>>**: ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆè©³ç´°
* **<<detection-system>>**: ç‰©ä½“ãƒ»å§¿å‹¢æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ 
* **<<database-schema>>**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒ
* **<<performance-optimization>>**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

=== ğŸ› ï¸ é–‹ç™ºè€…å‘ã‘ãƒªã‚½ãƒ¼ã‚¹
* **<<backend-architecture>>**: ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
* **<<development-guide>>**: é–‹ç™ºã‚¬ã‚¤ãƒ‰
* **<<rest-api-reference>>**: REST APIä»•æ§˜
* **<<testing-strategy>>**: ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

=== ğŸ“Š é‹ç”¨ãƒ»ä¿å®ˆé–¢é€£
* **<<operations-monitoring>>**: é‹ç”¨ç›£è¦–
* **<<troubleshooting-guide>>**: ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
* **<<configuration-guide>>**: è¨­å®šç®¡ç†
* **<<maintenance-procedures>>**: ä¿å®ˆæ‰‹é †

[NOTE]
====
ğŸ”„ **ç¶™ç¶šçš„æ”¹å–„**

ç›£è¦–ã‚³ã‚¢æ©Ÿèƒ½ã¯é‹ç”¨å®Ÿç¸¾ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦
ç¶™ç¶šçš„ã«æœ€é©åŒ–ã•ã‚Œã¾ã™ã€‚

**ç›£è¦–å“è³ª**: æ¤œå‡ºç²¾åº¦ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ã®ç¶™ç¶šçš„æ”¹å–„ +
**ãƒªã‚½ãƒ¼ã‚¹åŠ¹ç‡**: CPU/ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æœ€é©åŒ– +
**å¯ç”¨æ€§**: ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨å¾©æ—§æ©Ÿèƒ½ã®å¼·åŒ–

**ã‚¢ãƒ©ãƒ¼ãƒˆç²¾åº¦**: èª¤æ¤œçŸ¥å‰Šæ¸›ã¨é©åˆ‡ãªé€šçŸ¥ã‚¿ã‚¤ãƒŸãƒ³ã‚° +
**ãƒ‡ãƒ¼ã‚¿å“è³ª**: åé›†ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ã¨å®Œå…¨æ€§ã®ç¢ºä¿
====

---

**ğŸ“ Contact**: team@kanshichan.dev +
**ğŸ”— Repository**: https://github.com/kanshichan/backend +
**ğŸ“… Last Updated**: {docdate} +
**ğŸ“ Document Version**: {revnumber} 