=  🎯 監視ちゃん(KanshiChan) 監視コア機能設計
:toc: left
:toc-title: 目次
:toclevels: 4
:numbered:
:source-highlighter: highlight.js
:icons: font
:doctype: book
:version: 1.0.0
:author: KanshiChan Development Team
:email: team@kanshichan.dev
:revnumber: 1.0
:revdate: {docdate}
:experimental:

== 📖 概要

監視ちゃん（KanshiChan）バックエンドシステムの監視コア機能詳細設計ドキュメントです。
監視ループ、状態管理、アラート機能、データ収集機能の実装詳細と運用手順を包括的に説明します。

[NOTE]
====
📋 **ドキュメント情報**

* **対象読者**: バックエンド開発者、システムエンジニア、監視システム担当者
* **前提知識**: Python/Flask、Redis、リアルタイム処理、スレッド・プロセス管理
* **監視性能目標**: フレーム処理 15FPS、検出遅延 < 100ms、状態更新 < 10ms
* **可用性目標**: 99.9%、監視ループ復旧時間 < 30秒
* **最終更新**: {docdate}

**関連ドキュメント**: <<system-design>>, <<detection-system>>, <<performance-optimization>>
====

== 🎯 監視コア機能アーキテクチャ

=== 🏗️ 全体構成

[mermaid]
....
graph TB
    subgraph "🎯 Monitoring Core"
        MONITOR[Monitor Controller<br/>監視制御]
        LOOP[Monitoring Loop<br/>監視ループ]
        STATE[State Manager<br/>状態管理]
        ALERT[Alert Manager<br/>アラート管理]
    end
    
    subgraph "🔍 Detection Engine"
        CAMERA[Camera Manager<br/>カメラ管理]
        FRAME_PROC[Frame Processor<br/>フレーム処理]
        AI_DETECT[AI Detector<br/>AI検出エンジン]
        RESULT_PROC[Result Processor<br/>結果処理]
    end
    
    subgraph "💾 Data Management"
        REDIS_STORE[Redis Storage<br/>データ保存]
        CACHE_MGR[Cache Manager<br/>キャッシュ管理]
        SESSION_MGR[Session Manager<br/>セッション管理]
        PERF_MONITOR[Performance Monitor<br/>性能監視]
    end
    
    subgraph "📡 Communication"
        WS_BROADCAST[WebSocket Broadcaster<br/>リアルタイム配信]
        API_HANDLER[API Handler<br/>API処理]
        EVENT_EMITTER[Event Emitter<br/>イベント送信]
        LOGGER[Logger<br/>ログ出力]
    end
    
    subgraph "⚙️ Configuration"
        CONFIG_MGR[Config Manager<br/>設定管理]
        SCHEDULE_MGR[Schedule Manager<br/>スケジュール管理]
        RESOURCE_MGR[Resource Manager<br/>リソース管理]
    end
    
    %% Core flow
    MONITOR --> LOOP
    LOOP --> STATE
    STATE --> ALERT
    
    %% Detection flow
    CAMERA --> FRAME_PROC
    FRAME_PROC --> AI_DETECT
    AI_DETECT --> RESULT_PROC
    RESULT_PROC --> STATE
    
    %% Data flow
    STATE --> REDIS_STORE
    ALERT --> CACHE_MGR
    LOOP --> SESSION_MGR
    MONITOR --> PERF_MONITOR
    
    %% Communication flow
    STATE --> WS_BROADCAST
    ALERT --> EVENT_EMITTER
    MONITOR --> API_HANDLER
    LOOP --> LOGGER
    
    %% Configuration flow
    CONFIG_MGR --> MONITOR
    SCHEDULE_MGR --> LOOP
    RESOURCE_MGR --> CAMERA
    
    classDef core fill:#e3f2fd
    classDef detection fill:#e8f5e8
    classDef data fill:#fff3e0
    classDef communication fill:#f3e5f5
    classDef config fill:#fce4ec
    
    class MONITOR,LOOP,STATE,ALERT core
    class CAMERA,FRAME_PROC,AI_DETECT,RESULT_PROC detection
    class REDIS_STORE,CACHE_MGR,SESSION_MGR,PERF_MONITOR data
    class WS_BROADCAST,API_HANDLER,EVENT_EMITTER,LOGGER communication
    class CONFIG_MGR,SCHEDULE_MGR,RESOURCE_MGR config
....

=== 📊 監視コア機能概要

[cols="2,2,2,2", options="header"]
|===
|機能分類 |主要コンポーネント |責務 |パフォーマンス目標
|**監視制御** |Monitor Controller |監視の開始・停止・制御 |起動時間 < 10秒
|**監視ループ** |Monitoring Loop |連続的な監視処理実行 |処理頻度 15-30 FPS
|**状態管理** |State Manager |システム状態の管理・更新 |状態更新 < 10ms
|**アラート管理** |Alert Manager |条件判定・通知実行 |アラート遅延 < 1秒
|===

== 🔄 監視ループ詳細設計

=== ⚡ メイン監視ループフロー

[mermaid]
....
flowchart TD
    START([監視開始])
    
    %% 初期化フェーズ
    INIT_CHECK{初期化完了?}
    INIT_SYSTEM[システム初期化]
    INIT_CAMERA[カメラ初期化]
    INIT_AI[AI モデル初期化]
    
    %% メインループ
    LOOP_START{監視継続?}
    FRAME_CAPTURE[フレーム取得]
    FRAME_VALID{フレーム有効?}
    
    %% 処理判定
    SCHEDULE_CHECK{スケジュール確認}
    PROCESSING_LOAD{処理負荷確認}
    SKIP_FRAME[フレームスキップ]
    
    %% AI処理
    AI_PROCESSING[AI検出処理]
    RESULT_VALIDATE{結果検証}
    RESULT_PROCESS[結果処理]
    
    %% 状態管理
    STATE_UPDATE[状態更新]
    ALERT_CHECK{アラート条件?}
    TRIGGER_ALERT[アラート発動]
    
    %% データ管理
    DATA_STORE[データ保存]
    CACHE_UPDATE[キャッシュ更新]
    BROADCAST[状態配信]
    
    %% パフォーマンス管理
    PERF_CHECK{性能監視}
    MEMORY_CHECK{メモリ確認}
    RESOURCE_CLEANUP[リソースクリーンアップ]
    
    %% エラーハンドリング
    ERROR_HANDLE[エラー処理]
    RECOVERY[復旧処理]
    
    STOP[監視停止]
    CLEANUP[最終クリーンアップ]
    END([終了])
    
    %% フロー接続
    START --> INIT_CHECK
    INIT_CHECK -->|No| INIT_SYSTEM
    INIT_CHECK -->|Yes| LOOP_START
    
    INIT_SYSTEM --> INIT_CAMERA
    INIT_CAMERA --> INIT_AI
    INIT_AI --> INIT_CHECK
    
    LOOP_START -->|Yes| FRAME_CAPTURE
    LOOP_START -->|No| STOP
    
    FRAME_CAPTURE --> FRAME_VALID
    FRAME_VALID -->|Valid| SCHEDULE_CHECK
    FRAME_VALID -->|Invalid| ERROR_HANDLE
    
    SCHEDULE_CHECK -->|Active| PROCESSING_LOAD
    SCHEDULE_CHECK -->|Inactive| LOOP_START
    
    PROCESSING_LOAD -->|Normal| AI_PROCESSING
    PROCESSING_LOAD -->|High| SKIP_FRAME
    SKIP_FRAME --> LOOP_START
    
    AI_PROCESSING --> RESULT_VALIDATE
    RESULT_VALIDATE -->|Valid| RESULT_PROCESS
    RESULT_VALIDATE -->|Invalid| ERROR_HANDLE
    
    RESULT_PROCESS --> STATE_UPDATE
    STATE_UPDATE --> ALERT_CHECK
    
    ALERT_CHECK -->|Yes| TRIGGER_ALERT
    ALERT_CHECK -->|No| DATA_STORE
    TRIGGER_ALERT --> DATA_STORE
    
    DATA_STORE --> CACHE_UPDATE
    CACHE_UPDATE --> BROADCAST
    BROADCAST --> PERF_CHECK
    
    PERF_CHECK -->|Normal| LOOP_START
    PERF_CHECK -->|Issue| MEMORY_CHECK
    
    MEMORY_CHECK -->|OK| LOOP_START
    MEMORY_CHECK -->|Critical| RESOURCE_CLEANUP
    RESOURCE_CLEANUP --> LOOP_START
    
    ERROR_HANDLE --> RECOVERY
    RECOVERY --> LOOP_START
    
    STOP --> CLEANUP
    CLEANUP --> END
    
    classDef start fill:#e8f5e8
    classDef process fill:#e3f2fd
    classDef decision fill:#fff3e0
    classDef error fill:#ffebee
    classDef end fill:#f3e5f5
    
    class START,END start
    class INIT_SYSTEM,AI_PROCESSING,STATE_UPDATE,DATA_STORE process
    class INIT_CHECK,FRAME_VALID,SCHEDULE_CHECK,ALERT_CHECK decision
    class ERROR_HANDLE,RECOVERY error
    class STOP,CLEANUP end
....

=== 🔧 監視ループ実装詳細

```python
# Core monitoring loop implementation
class MonitoringLoop:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.is_running = False
        self.loop_stats = LoopStatistics()
        self.error_handler = ErrorHandler()
        
        # 監視コンポーネント
        self.camera_manager = CameraManager(config_manager)
        self.frame_processor = FrameProcessor(config_manager)
        self.ai_detector = AIDetector(config_manager)
        self.state_manager = StateManager(config_manager)
        self.alert_manager = AlertManager(config_manager)
        
        # パフォーマンス監視
        self.performance_monitor = PerformanceMonitor()
        self.resource_manager = ResourceManager()
        
    async def start_monitoring(self):
        """監視ループの開始"""
        try:
            await self._initialize_system()
            self.is_running = True
            
            logger.info("Monitoring loop started")
            await self._main_monitoring_loop()
            
        except Exception as e:
            self.error_handler.handle_critical_error(e)
            raise
        finally:
            await self._cleanup_system()
    
    async def _main_monitoring_loop(self):
        """メイン監視ループ"""
        while self.is_running:
            loop_start_time = time.time()
            
            try:
                # フレーム取得
                frame = await self.camera_manager.capture_frame()
                if frame is None:
                    continue
                
                # スケジュール確認
                if not self._is_monitoring_active():
                    await asyncio.sleep(1.0)
                    continue
                
                # 処理負荷確認
                if self._should_skip_frame():
                    self.loop_stats.increment_skipped_frames()
                    continue
                
                # AI検出処理
                detection_result = await self._process_frame(frame)
                
                # 状態更新とアラートチェック
                await self._update_system_state(detection_result)
                
                # データ保存と配信
                await self._store_and_broadcast(detection_result)
                
                # パフォーマンス監視
                await self._monitor_performance(loop_start_time)
                
            except Exception as e:
                await self.error_handler.handle_loop_error(e)
                await asyncio.sleep(0.1)  # エラー時は少し待機
    
    async def _process_frame(self, frame: np.ndarray) -> DetectionResult:
        """フレーム処理"""
        try:
            # フレーム前処理
            processed_frame = await self.frame_processor.preprocess(frame)
            
            # AI検出実行
            detection_result = await self.ai_detector.detect(processed_frame)
            
            # 結果検証
            if not self._validate_detection_result(detection_result):
                raise ValidationError("Invalid detection result")
            
            return detection_result
            
        except Exception as e:
            self.error_handler.handle_processing_error(e)
            return DetectionResult.empty()
    
    async def _update_system_state(self, detection_result: DetectionResult):
        """システム状態更新"""
        # 状態管理更新
        state_changed = await self.state_manager.update_state(detection_result)
        
        # アラート条件チェック
        if state_changed:
            await self.alert_manager.check_alert_conditions(
                self.state_manager.get_current_state()
            )
    
    def _is_monitoring_active(self) -> bool:
        """監視アクティブ判定"""
        current_schedule = self.config.schedule_manager.get_current_schedule()
        return current_schedule and current_schedule.monitoring_enabled
    
    def _should_skip_frame(self) -> bool:
        """フレームスキップ判定"""
        # CPU/GPU使用率確認
        cpu_usage = self.performance_monitor.get_cpu_usage()
        memory_usage = self.performance_monitor.get_memory_usage()
        
        # 負荷が高い場合はスキップ
        if cpu_usage > 80 or memory_usage > 85:
            return True
        
        # 適応的スキップ（FPS調整）
        current_fps = self.loop_stats.get_current_fps()
        target_fps = self.config.get_target_fps()
        
        return current_fps > target_fps * 1.2
```

== 🎛️ 状態管理システム

=== 📊 状態管理アーキテクチャ

[mermaid]
....
stateDiagram-v2
    [*] --> INITIALIZING
    INITIALIZING --> PRESENT : 人検出
    INITIALIZING --> ABSENT : 人未検出
    INITIALIZING --> UNKNOWN : 判定不能
    
    PRESENT --> ABSENT : 不在検出
    PRESENT --> SMARTPHONE_DETECTED : スマホ検出
    PRESENT --> PRESENT : 人継続検出
    
    ABSENT --> PRESENT : 人検出
    ABSENT --> ABSENT : 不在継続
    
    SMARTPHONE_DETECTED --> PRESENT : スマホ未検出
    SMARTPHONE_DETECTED --> ABSENT : 人未検出
    SMARTPHONE_DETECTED --> SMARTPHONE_DETECTED : スマホ継続使用
    
    UNKNOWN --> PRESENT : 人検出
    UNKNOWN --> ABSENT : 不在確定
    UNKNOWN --> UNKNOWN : 判定不能継続
    
    PRESENT --> [*] : システム停止
    ABSENT --> [*] : システム停止
    SMARTPHONE_DETECTED --> [*] : システム停止
    UNKNOWN --> [*] : システム停止
....

=== 🔄 状態遷移管理

```python
# State management implementation
class StateManager:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.current_state = MonitoringState.INITIALIZING
        self.previous_state = None
        self.state_history = []
        
        # タイマー管理
        self.absence_start_time = None
        self.smartphone_start_time = None
        self.state_change_time = time.time()
        
        # 統計情報
        self.state_statistics = StateStatistics()
        
    async def update_state(self, detection_result: DetectionResult) -> bool:
        """状態更新"""
        new_state = self._determine_new_state(detection_result)
        
        if new_state != self.current_state:
            await self._transition_state(new_state, detection_result)
            return True
        else:
            self._update_state_timers(detection_result)
            return False
    
    def _determine_new_state(self, detection_result: DetectionResult) -> MonitoringState:
        """新しい状態の決定"""
        # 信頼度チェック
        if not self._is_reliable_detection(detection_result):
            return self.current_state  # 信頼度が低い場合は状態変更しない
        
        # 状態判定ロジック
        if detection_result.person_detected:
            if detection_result.smartphone_detected:
                return MonitoringState.SMARTPHONE_DETECTED
            else:
                return MonitoringState.PRESENT
        else:
            return MonitoringState.ABSENT
    
    async def _transition_state(self, new_state: MonitoringState, detection_result: DetectionResult):
        """状態遷移処理"""
        old_state = self.current_state
        transition_time = time.time()
        
        # 状態遷移記録
        transition = StateTransition(
            from_state=old_state,
            to_state=new_state,
            timestamp=transition_time,
            trigger="detection_result",
            confidence=detection_result.get_max_confidence(),
            context=detection_result.to_dict()
        )
        
        # 状態更新
        self.previous_state = old_state
        self.current_state = new_state
        self.state_change_time = transition_time
        
        # タイマー管理
        self._manage_state_timers(new_state, transition_time)
        
        # 履歴記録
        self.state_history.append(transition)
        self._trim_history()
        
        # 統計更新
        self.state_statistics.record_transition(transition)
        
        # 状態遷移イベント発生
        await self._emit_state_change_event(transition)
        
        logger.info(f"State transition: {old_state.name} -> {new_state.name}")
    
    def _manage_state_timers(self, new_state: MonitoringState, timestamp: float):
        """状態タイマー管理"""
        if new_state == MonitoringState.ABSENT:
            if self.absence_start_time is None:
                self.absence_start_time = timestamp
        else:
            self.absence_start_time = None
        
        if new_state == MonitoringState.SMARTPHONE_DETECTED:
            if self.smartphone_start_time is None:
                self.smartphone_start_time = timestamp
        else:
            self.smartphone_start_time = None
    
    def get_absence_duration(self) -> int:
        """不在時間の取得"""
        if self.absence_start_time is None:
            return 0
        return int(time.time() - self.absence_start_time)
    
    def get_smartphone_usage_duration(self) -> int:
        """スマホ使用時間の取得"""
        if self.smartphone_start_time is None:
            return 0
        return int(time.time() - self.smartphone_start_time)
    
    def _is_reliable_detection(self, detection_result: DetectionResult) -> bool:
        """検出結果の信頼度判定"""
        min_confidence = self.config.get_min_confidence_threshold()
        
        # 人検出の信頼度
        if detection_result.person_detected:
            if detection_result.person_confidence < min_confidence:
                return False
        
        # スマホ検出の信頼度
        if detection_result.smartphone_detected:
            if detection_result.smartphone_confidence < min_confidence:
                return False
        
        return True
```

== 🚨 アラート管理システム

=== 📋 アラート機能アーキテクチャ

[mermaid]
....
graph TB
    subgraph "🔍 Detection & Triggers"
        CONDITION[Condition Evaluator<br/>条件評価]
        TIMER[Timer Manager<br/>タイマー管理]
        PATTERN[Pattern Detector<br/>パターン検出]
        THRESHOLD[Threshold Monitor<br/>閾値監視]
    end
    
    subgraph "⚙️ Alert Processing"
        RULE_ENGINE[Rule Engine<br/>ルールエンジン]
        PRIORITY[Priority Manager<br/>優先度管理]
        THROTTLE[Throttling<br/>制限制御]
        DEDUP[Deduplication<br/>重複排除]
    end
    
    subgraph "📢 Notification Channels"
        TTS[TTS Notification<br/>音声通知]
        SOUND[Sound Alert<br/>音声アラート]
        WEBSOCKET[WebSocket<br/>リアルタイム通知]
        LINE_MSG[LINE Message<br/>LINE通知]
        LOG[Log Output<br/>ログ出力]
    end
    
    subgraph "📊 Alert Management"
        HISTORY[Alert History<br/>アラート履歴]
        ANALYTICS[Alert Analytics<br/>分析]
        CONFIG[Alert Config<br/>設定管理]
        TESTING[Testing Mode<br/>テストモード]
    end
    
    %% Detection to Processing
    CONDITION --> RULE_ENGINE
    TIMER --> RULE_ENGINE
    PATTERN --> PRIORITY
    THRESHOLD --> THROTTLE
    
    %% Processing flow
    RULE_ENGINE --> PRIORITY
    PRIORITY --> THROTTLE
    THROTTLE --> DEDUP
    
    %% Notification dispatch
    DEDUP --> TTS
    DEDUP --> SOUND
    DEDUP --> WEBSOCKET
    DEDUP --> LINE_MSG
    DEDUP --> LOG
    
    %% Management
    RULE_ENGINE --> HISTORY
    PRIORITY --> ANALYTICS
    CONFIG --> RULE_ENGINE
    TESTING --> DEDUP
    
    classDef detection fill:#e3f2fd
    classDef processing fill:#e8f5e8
    classDef notification fill:#fff3e0
    classDef management fill:#f3e5f5
    
    class CONDITION,TIMER,PATTERN,THRESHOLD detection
    class RULE_ENGINE,PRIORITY,THROTTLE,DEDUP processing
    class TTS,SOUND,WEBSOCKET,LINE_MSG,LOG notification
    class HISTORY,ANALYTICS,CONFIG,TESTING management
....

=== 🔔 アラートルール定義

```python
# Alert rules and conditions
class AlertRuleEngine:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.active_alerts = {}
        self.alert_history = []
        self.notification_throttle = NotificationThrottle()
        
        # アラートルール定義
        self.rules = [
            AbsenceAlertRule(),
            SmartphoneUsageAlertRule(),
            SystemHealthAlertRule(),
            PerformanceAlertRule()
        ]
    
    async def evaluate_alerts(self, current_state: MonitoringState, 
                            state_manager: StateManager) -> List[Alert]:
        """アラート条件評価"""
        triggered_alerts = []
        
        for rule in self.rules:
            if rule.is_enabled():
                alert = await rule.evaluate(current_state, state_manager)
                if alert:
                    # 重複チェック
                    if not self._is_duplicate_alert(alert):
                        # 制限チェック
                        if self.notification_throttle.can_send(alert):
                            triggered_alerts.append(alert)
                            await self._process_alert(alert)
        
        return triggered_alerts
    
    async def _process_alert(self, alert: Alert):
        """アラート処理"""
        # アラート記録
        self.active_alerts[alert.id] = alert
        self.alert_history.append(alert)
        
        # 通知送信
        await self._send_notifications(alert)
        
        # 統計更新
        self._update_alert_statistics(alert)
        
        logger.warning(f"Alert triggered: {alert.type.name} - {alert.message}")

# Alert rule implementations
class AbsenceAlertRule(AlertRule):
    def __init__(self):
        super().__init__("absence_alert", AlertType.ABSENCE)
        self.absence_threshold = 300  # 5分
    
    async def evaluate(self, current_state: MonitoringState, 
                      state_manager: StateManager) -> Optional[Alert]:
        if current_state == MonitoringState.ABSENT:
            absence_duration = state_manager.get_absence_duration()
            
            if absence_duration >= self.absence_threshold:
                return Alert(
                    id=str(uuid.uuid4()),
                    type=AlertType.ABSENCE,
                    message=f"不在が{absence_duration}秒継続しています",
                    severity=AlertSeverity.WARNING,
                    context={
                        "absence_duration": absence_duration,
                        "threshold": self.absence_threshold
                    }
                )
        return None

class SmartphoneUsageAlertRule(AlertRule):
    def __init__(self):
        super().__init__("smartphone_usage", AlertType.SMARTPHONE_USAGE)
        self.usage_threshold = 600  # 10分
    
    async def evaluate(self, current_state: MonitoringState, 
                      state_manager: StateManager) -> Optional[Alert]:
        if current_state == MonitoringState.SMARTPHONE_DETECTED:
            usage_duration = state_manager.get_smartphone_usage_duration()
            
            if usage_duration >= self.usage_threshold:
                return Alert(
                    id=str(uuid.uuid4()),
                    type=AlertType.SMARTPHONE_USAGE,
                    message=f"スマートフォン使用が{usage_duration}秒継続しています",
                    severity=AlertSeverity.INFO,
                    context={
                        "usage_duration": usage_duration,
                        "threshold": self.usage_threshold
                    }
                )
        return None
```

== 📊 データ収集・保存機能

=== 💾 データ収集戦略

[mermaid]
....
graph LR
    subgraph "📥 Data Sources"
        DETECTION[Detection Results<br/>検出結果]
        STATE[State Changes<br/>状態変更]
        PERFORMANCE[Performance Metrics<br/>性能メトリクス]
        ALERTS[Alert Events<br/>アラートイベント]
        SYSTEM[System Health<br/>システム状態]
    end
    
    subgraph "🔄 Processing Pipeline"
        VALIDATE[Data Validation<br/>データ検証]
        TRANSFORM[Data Transform<br/>データ変換]
        ENRICH[Data Enrichment<br/>データ拡張]
        BATCH[Batch Processing<br/>バッチ処理]
    end
    
    subgraph "💾 Storage Layer"
        REDIS_REALTIME[Redis Real-time<br/>リアルタイムデータ]
        REDIS_ANALYTICS[Redis Analytics<br/>分析データ]
        FILE_STORAGE[File Storage<br/>ファイル保存]
        BACKUP[Backup Storage<br/>バックアップ]
    end
    
    subgraph "📊 Data Access"
        QUERY_API[Query API<br/>クエリAPI]
        AGGREGATION[Data Aggregation<br/>データ集約]
        EXPORT[Data Export<br/>データエクスポート]
        REPORTING[Reporting<br/>レポート生成]
    end
    
    %% Data flow
    DETECTION --> VALIDATE
    STATE --> VALIDATE
    PERFORMANCE --> TRANSFORM
    ALERTS --> ENRICH
    SYSTEM --> BATCH
    
    VALIDATE --> TRANSFORM
    TRANSFORM --> ENRICH
    ENRICH --> BATCH
    
    BATCH --> REDIS_REALTIME
    BATCH --> REDIS_ANALYTICS
    BATCH --> FILE_STORAGE
    REDIS_REALTIME --> BACKUP
    
    REDIS_REALTIME --> QUERY_API
    REDIS_ANALYTICS --> AGGREGATION
    FILE_STORAGE --> EXPORT
    BACKUP --> REPORTING
    
    classDef source fill:#e3f2fd
    classDef processing fill:#e8f5e8
    classDef storage fill:#fff3e0
    classDef access fill:#f3e5f5
    
    class DETECTION,STATE,PERFORMANCE,ALERTS,SYSTEM source
    class VALIDATE,TRANSFORM,ENRICH,BATCH processing
    class REDIS_REALTIME,REDIS_ANALYTICS,FILE_STORAGE,BACKUP storage
    class QUERY_API,AGGREGATION,EXPORT,REPORTING access
....

=== 🗃️ データ収集実装

```python
# Data collection implementation
class DataCollector:
    def __init__(self, config_manager: ConfigManager):
        self.config = config_manager
        self.redis_client = RedisClient()
        self.data_validator = DataValidator()
        self.batch_processor = BatchProcessor()
        
        # データ収集統計
        self.collection_stats = CollectionStatistics()
        
    async def collect_detection_data(self, detection_result: DetectionResult, 
                                   session_id: str):
        """検出データの収集"""
        try:
            # データ検証
            if not self.data_validator.validate_detection_result(detection_result):
                raise ValidationError("Invalid detection result")
            
            # データ拡張
            enriched_data = self._enrich_detection_data(detection_result, session_id)
            
            # リアルタイム保存
            await self._store_realtime_data(enriched_data)
            
            # バッチ処理用キューに追加
            await self.batch_processor.add_to_queue("detection", enriched_data)
            
            self.collection_stats.increment_detection_count()
            
        except Exception as e:
            logger.error(f"Failed to collect detection data: {e}")
            self.collection_stats.increment_error_count()
    
    async def collect_state_change(self, state_transition: StateTransition):
        """状態変更データの収集"""
        try:
            # 状態変更データ構築
            state_data = {
                "transition_id": str(uuid.uuid4()),
                "timestamp": state_transition.timestamp,
                "from_state": state_transition.from_state.name,
                "to_state": state_transition.to_state.name,
                "trigger": state_transition.trigger,
                "confidence": state_transition.confidence,
                "duration": self._calculate_state_duration(state_transition),
                "context": state_transition.context
            }
            
            # タイムライン更新
            await self._update_behavior_timeline(state_data)
            
            # 統計更新
            await self._update_behavior_statistics(state_data)
            
        except Exception as e:
            logger.error(f"Failed to collect state change: {e}")
    
    async def collect_performance_metrics(self, metrics: dict):
        """パフォーマンスメトリクスの収集"""
        try:
            timestamp = time.time()
            metric_id = f"metrics:{int(timestamp)}"
            
            # メトリクスデータ構築
            metrics_data = {
                "metric_id": metric_id,
                "timestamp": timestamp,
                "instance_id": self.config.get_instance_id(),
                **metrics
            }
            
            # Redis保存（短期間）
            await self.redis_client.setex(
                metric_id, 3600, json.dumps(metrics_data)
            )
            
            # 時系列インデックス更新
            await self.redis_client.zadd(
                f"metrics:index:instance:{self.config.get_instance_id()}",
                {metric_id: timestamp}
            )
            
        except Exception as e:
            logger.error(f"Failed to collect performance metrics: {e}")
    
    def _enrich_detection_data(self, detection_result: DetectionResult, 
                              session_id: str) -> dict:
        """検出データの拡張"""
        return {
            "detection_id": str(uuid.uuid4()),
            "session_id": session_id,
            "timestamp": time.time(),
            "instance_id": self.config.get_instance_id(),
            **detection_result.to_dict(),
            "enriched_metadata": {
                "processing_node": self.config.get_node_id(),
                "model_versions": self._get_model_versions(),
                "system_state": self._get_system_state()
            }
        }
```

== 🔗 関連ドキュメント

=== 📖 必須参照ドキュメント
* **<<system-design>>**: システム設計詳細
* **<<detection-system>>**: 物体・姿勢検出システム
* **<<database-schema>>**: データベーススキーマ
* **<<performance-optimization>>**: パフォーマンス最適化

=== 🛠️ 開発者向けリソース
* **<<backend-architecture>>**: システムアーキテクチャ
* **<<development-guide>>**: 開発ガイド
* **<<rest-api-reference>>**: REST API仕様
* **<<testing-strategy>>**: テスト戦略

=== 📊 運用・保守関連
* **<<operations-monitoring>>**: 運用監視
* **<<troubleshooting-guide>>**: トラブルシューティング
* **<<configuration-guide>>**: 設定管理
* **<<maintenance-procedures>>**: 保守手順

[NOTE]
====
🔄 **継続的改善**

監視コア機能は運用実績とパフォーマンスデータに基づいて
継続的に最適化されます。

**監視品質**: 検出精度とレスポンス時間の継続的改善 +
**リソース効率**: CPU/メモリ使用量の最適化 +
**可用性**: エラー処理と復旧機能の強化

**アラート精度**: 誤検知削減と適切な通知タイミング +
**データ品質**: 収集データの整合性と完全性の確保
====

---

**📞 Contact**: team@kanshichan.dev +
**🔗 Repository**: https://github.com/kanshichan/backend +
**📅 Last Updated**: {docdate} +
**📝 Document Version**: {revnumber} 