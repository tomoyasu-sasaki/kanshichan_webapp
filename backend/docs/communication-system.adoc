= ğŸ”— é€šä¿¡ãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ  - Communication & Notification System
:author: KanshiChan Development Team
:version: 1.0
:date: 2024-12-27
:target_audience: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºè€…ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™ºè€…
:document_type: ã‚·ã‚¹ãƒ†ãƒ è©³ç´°ä»•æ§˜æ›¸
:toc: left
:toclevels: 4
:sectnums:
:source-highlighter: highlight.js

== ğŸ“‹ æ¦‚è¦

=== ğŸ“– ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€KanshiChanã‚·ã‚¹ãƒ†ãƒ ã®é€šä¿¡ãƒ»é€šçŸ¥æ©Ÿèƒ½ã«ãŠã‘ã‚‹è©³ç´°ãªæŠ€è¡“ä»•æ§˜ã¨ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’å®šç¾©ã—ã¾ã™ã€‚

**å¯¾è±¡èª­è€…**: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–‹ç™ºè€…ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™ºè€… +
**å‰æçŸ¥è­˜**: Python/Flaskã€WebSocketã€TTSæŠ€è¡“ +
**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: <<websocket-api>>, <<rest-api-reference>>, <<system-design>>

=== ğŸ¯ ã‚·ã‚¹ãƒ†ãƒ ç›®çš„

* **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡**: WebSocketãƒ™ãƒ¼ã‚¹ã®åŒæ–¹å‘é€šä¿¡
* **æ™ºæ…§çš„é€šçŸ¥**: æ–‡è„ˆã«å¿œã˜ãŸã‚¢ãƒ©ãƒ¼ãƒˆé…ä¿¡
* **éŸ³å£°åˆæˆ**: TTSæŠ€è¡“ã«ã‚ˆã‚‹å‹•çš„éŸ³å£°ç”Ÿæˆ
* **ãƒãƒ«ãƒãƒãƒ£ãƒãƒ«é…ä¿¡**: LINE APIã€éŸ³å£°ã€ç”»é¢é€šçŸ¥ã®çµ±åˆ

=== ğŸ—ï¸ ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆæ¦‚è¦

[mermaid]
....
graph TB
    subgraph "ğŸŒ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå±¤"
        WEB[Web Frontend]
        MOBILE[Mobile Client]
    end
    
    subgraph "ğŸ”— é€šä¿¡å±¤"
        WS[WebSocket Handler]
        REST[REST API]
        SB[Status Broadcaster]
    end
    
    subgraph "ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆã‚¨ãƒ³ã‚¸ãƒ³"
        AM[Alert Manager]
        AS[Alert Service]
        ND[Notification Delivery]
    end
    
    subgraph "ğŸ”Š éŸ³å£°ã‚·ã‚¹ãƒ†ãƒ "
        TTS[TTS Service]
        SOUND[Sound Service]
        STREAM[Audio Streaming]
    end
    
    subgraph "ğŸ“± å¤–éƒ¨é€£æº"
        LINE[LINE API]
        EMAIL[Email Service]
        PUSH[Push Notification]
    end
    
    subgraph "ğŸ§  ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ "
        MONITOR[Monitor Engine]
        STATE[State Manager]
        DETECTOR[Object Detector]
    end
    
    %% é€šä¿¡ãƒ•ãƒ­ãƒ¼
    WEB <==> WS
    MOBILE <==> REST
    WS --> SB
    SB --> AM
    AM --> AS
    AS --> ND
    
    %% éŸ³å£°ãƒ•ãƒ­ãƒ¼
    TTS --> SOUND
    TTS --> STREAM
    STREAM --> WS
    
    %% å¤–éƒ¨é€£æº
    ND --> LINE
    ND --> EMAIL
    ND --> PUSH
    
    %% ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ é€£æº
    MONITOR --> STATE
    STATE --> SB
    DETECTOR --> AM
    
    classDef client fill:#e3f2fd
    classDef communication fill:#e8f5e8
    classDef alert fill:#fff3e0
    classDef audio fill:#f3e5f5
    classDef external fill:#fce4ec
    classDef core fill:#e8eaf6
    
    class WEB,MOBILE client
    class WS,REST,SB communication
    class AM,AS,ND alert
    class TTS,SOUND,STREAM audio
    class LINE,EMAIL,PUSH external
    class MONITOR,STATE,DETECTOR core
....

== ğŸŒ WebSocketé€šä¿¡ã‚·ã‚¹ãƒ†ãƒ 

=== ğŸ“¡ WebSocketã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

[mermaid]
....
classDiagram
    class WebSocketManager {
        -socketio: SocketIO
        -connected_clients: List[str]
        -audio_queue: Queue
        
        +init_websocket(app: Flask): void
        +handle_connect(): void
        +handle_disconnect(): void
        +broadcast_status(status: dict): void
        +broadcast_audio_stream(audio_data: bytes): void
        +broadcast_audio_notification(type: str): void
    }
    
    class StatusBroadcaster {
        -detector: Detector
        -state_manager: StateManager
        -frame_lock: threading.Lock
        
        +broadcast_status(): void
        +broadcast_behavior_data(data: dict): void
        +broadcast_analysis_results(results: dict): void
        +broadcast_enhanced_status(status: dict): void
    }
    
    class AudioStreamHandler {
        -audio_queue: Queue
        -connected_clients: List[str]
        
        +queue_audio_for_streaming(file_path: str): void
        +stream_audio_to_clients(audio_data: bytes): void
        +handle_audio_playback_status(status: dict): void
    }
    
    WebSocketManager --> StatusBroadcaster
    WebSocketManager --> AudioStreamHandler
....

=== ğŸ”Œ æ¥ç¶šç®¡ç†ã¨ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†

**åŸºæœ¬WebSocketå®Ÿè£…**

```python
# backend/src/web/websocket.py
from flask_socketio import SocketIO, emit
from flask import request
from utils.logger import setup_logger

logger = setup_logger(__name__)
socketio = SocketIO()
connected_clients: List[str] = []

def init_websocket(app):
    """WebSocketã®åˆæœŸåŒ–"""
    socketio.init_app(app, cors_allowed_origins="*")

    @socketio.on('connect')
    def handle_connect():
        client_id = request.sid
        connected_clients.append(client_id)
        logger.info(f'Client connected: {client_id}')

    @socketio.on('disconnect')
    def handle_disconnect():
        client_id = request.sid
        if client_id in connected_clients:
            connected_clients.remove(client_id)
        logger.info(f'Client disconnected: {client_id}')
```

=== ğŸ“¨ WebSocketã‚¤ãƒ™ãƒ³ãƒˆä»•æ§˜

[cols="1,2,3", options="header"]
|===
|ã‚¤ãƒ™ãƒ³ãƒˆå |æ–¹å‘ |ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
|**status_update** |Server â†’ Client |DetectionStatus
|**schedule_alert** |Server â†’ Client |ScheduleAlert
|**audio_stream** |Server â†’ Client |AudioStreamData
|**audio_notification** |Server â†’ Client |AudioNotification
|**audio_playback_status** |Client â†’ Server |PlaybackStatus
|**behavior_data** |Server â†’ Client |BehaviorData
|**analysis_results** |Server â†’ Client |AnalysisResults
|===

**ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿æ§‹é€ **

```typescript
// ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å‹å®šç¾©
interface DetectionStatus {
  personDetected: boolean;
  smartphoneDetected: boolean;
  absenceTime: number;
  smartphoneUseTime: number;
  absenceAlert?: boolean;
  smartphoneAlert?: boolean;
}

interface AudioStreamData {
  audio_data: string;  // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
  metadata: AudioMetadata;
  timestamp: string;
  format: string;
  encoding: string;
}

interface AudioNotification {
  type: 'tts_started' | 'tts_completed' | 'tts_error' | 'audio_ready';
  message: string;
  audio_id?: string;
  timestamp: string;
}
```

=== ğŸ”„ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹é…ä¿¡

```python
# backend/src/core/status_broadcaster.py
class StatusBroadcaster:
    def broadcast_enhanced_status(self, enhanced_status: Dict[str, Any]) -> None:
        """æ‹¡å¼µã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æƒ…å ±ã‚’WebSocketã§é…ä¿¡"""
        try:
            # MediaPipeã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®‰å…¨ãªå½¢å¼ã«å¤‰æ›
            safe_status = create_websocket_safe_status(enhanced_status)
            
            socketio.emit('status', safe_status)
            
            # å€‹åˆ¥ã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦ã‚‚é…ä¿¡
            if 'behavior_data' in safe_status:
                socketio.emit('behavior_data', safe_status['behavior_data'])
                
            if 'analysis_results' in safe_status:
                socketio.emit('analysis_results', safe_status['analysis_results'])
                
        except Exception as e:
            logger.error(f"Enhanced status broadcast error: {e}")
```

== ğŸš¨ ã‚¢ãƒ©ãƒ¼ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

=== ğŸ›ï¸ ã‚¢ãƒ©ãƒ¼ãƒˆã‚¨ãƒ³ã‚¸ãƒ³è¨­è¨ˆ

[mermaid]
....
classDiagram
    class AlertManager {
        -alert_config: dict
        -active_alerts: List[Alert]
        -sound_service: SoundService
        -tts_service: TTSService
        -line_service: LineService
        
        +trigger_alert(alert_type: AlertType): void
        +clear_alert(alert_id: str): void
        +get_active_alerts(): List[Alert]
        +schedule_alert(alert: Alert, delay: int): void
    }
    
    class Alert {
        +id: str
        +type: AlertType
        +message: str
        +severity: int
        +timestamp: datetime
        +context: dict
        +is_active: bool
        
        +to_dict(): dict
        +should_repeat(): bool
        +get_notification_channels(): List[str]
    }
    
    class AlertService {
        -config_manager: ConfigManager
        -line_service: LineService
        -sound_service: SoundService
        
        +trigger_alert(message: str): void
        +trigger_absence_alert(duration: float): void
        +trigger_smartphone_alert(duration: float): void
    }
    
    class NotificationDelivery {
        -delivery_stats: dict
        
        +deliver_alert(alert: AlertMessage, channel: AlertChannel): bool
        +_deliver_tts_alert(alert: AlertMessage): bool
        +_deliver_websocket_alert(alert: AlertMessage): bool
        +_deliver_email_alert(alert: AlertMessage): bool
    }
    
    AlertManager --> Alert
    AlertManager --> AlertService
    AlertService --> NotificationDelivery
....

=== ğŸ”” ã‚¢ãƒ©ãƒ¼ãƒˆç¨®é¡ã¨å‡¦ç†

**ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«éšå±¤**

```python
# backend/src/services/monitoring/alert_system.py
class AlertLevel(Enum):
    """ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«éšå±¤"""
    INFO = "info"
    WARNING = "warning" 
    ALERT = "alert"
    CRITICAL = "critical"

class AlertChannel(Enum):
    """ã‚¢ãƒ©ãƒ¼ãƒˆé…ä¿¡ãƒãƒ£ãƒãƒ«"""
    TTS_VOICE = "tts_voice"
    SCREEN_POPUP = "screen_popup"
    BROWSER_NOTIFICATION = "browser_notification"
    EMAIL = "email"
    WEBSOCKET = "websocket"
    LINE_API = "line_api"
```

**å°‚ç”¨ã‚¢ãƒ©ãƒ¼ãƒˆå‡¦ç†**

```python
# backend/src/services/communication/alert_service.py
class AlertService:
    def trigger_absence_alert(self, absence_duration):
        """ä¸åœ¨ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ãƒˆãƒªã‚¬ãƒ¼"""
        message = f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¸­ã‚’é›¢ã‚Œã¦ {absence_duration:.0f} ç§’ãŒçµŒéã—ã¾ã—ãŸã€‚"
        logger.warning(message)
        self._send_line_notify(f"ğŸš¶â€â™‚ï¸ ä¸åœ¨æ¤œçŸ¥: {message}")
        
        # ä¸åœ¨ã‚¢ãƒ©ãƒ¼ãƒˆç”¨ã®éŸ³å£°
        sound_file = self.alert_sounds.get("absence", "alert.wav")
        self.sound_service.play_alert(sound_file)

    def trigger_smartphone_alert(self, usage_duration):
        """ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ä½¿ç”¨ã‚¢ãƒ©ãƒ¼ãƒˆ"""
        message = f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã‚’ {usage_duration:.0f} ç§’é–“ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚"
        logger.warning(message)
        self._send_line_notify(f"ğŸ“± ã‚¹ãƒãƒ›ä½¿ç”¨æ¤œçŸ¥: {message}")
        
        sound_file = self.alert_sounds.get("smartphone", "alert.wav")
        self.sound_service.play_alert(sound_file)
```

=== ğŸ“± é€šçŸ¥é…ä¿¡ãƒãƒ£ãƒãƒ«

[mermaid]
....
sequenceDiagram
    participant AM as Alert Manager
    participant ND as Notification Delivery
    participant TTS as TTS Service
    participant WS as WebSocket
    participant LINE as LINE API
    participant EMAIL as Email Service
    
    AM->>ND: deliver_alert(alert, channels)
    
    alt TTS Voice Channel
        ND->>TTS: synthesize_alert_message()
        TTS-->>ND: audio_data
        ND->>WS: broadcast_audio_stream()
    end
    
    alt WebSocket Channel
        ND->>WS: broadcast_alert_notification()
        WS-->>Client: alert_event
    end
    
    alt LINE API Channel
        ND->>LINE: send_push_message()
        LINE-->>User: LINEé€šçŸ¥
    end
    
    alt Email Channel
        ND->>EMAIL: send_alert_email()
        EMAIL-->>User: ãƒ¡ãƒ¼ãƒ«é€šçŸ¥
    end
    
    ND-->>AM: delivery_results
....

== ğŸ”Š TTSéŸ³å£°åˆæˆã‚·ã‚¹ãƒ†ãƒ 

=== ğŸ™ï¸ TTS ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

[mermaid]
....
classDiagram
    class TTSService {
        -engine: ZonosTTS
        -voice_config: dict
        -audio_queue: Queue
        -emotion_manager: EmotionManager
        
        +synthesize_text(text: str, emotion: str): AudioData
        +synthesize_text_fast(text: str): AudioResult
        +play_tts_alert(message: str): void
        +get_available_voices(): List[str]
        +clone_voice(sample_data: bytes): VoiceModel
    }
    
    class SoundService {
        -audio_device: AudioDevice
        -sound_cache: dict
        -volume_level: float
        
        +play_sound(sound_file: str): void
        +play_tts_audio(audio_data: AudioData): void
        +play_alert(sound_file: str): void
        +set_volume(level: float): void
        +stop_all_sounds(): void
    }
    
    class EmotionManager {
        -emotion_profiles: dict
        
        +apply_emotion(audio: AudioData, emotion: str): AudioData
        +get_emotion_parameters(emotion: str): dict
        +blend_emotions(primary: str, secondary: str): dict
    }
    
    class AudioProcessor {
        +process_audio_quality(audio: AudioData): AudioData
        +apply_effects(audio: AudioData, effects: dict): AudioData
        +normalize_volume(audio: AudioData): AudioData
    }
    
    TTSService --> SoundService
    TTSService --> EmotionManager
    TTSService --> AudioProcessor
....

=== ğŸµ éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°æ©Ÿèƒ½

**ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³å£°é…ä¿¡**

```python
# backend/src/web/websocket.py
def broadcast_audio_stream(audio_data: bytes, audio_metadata: Dict[str, Any], 
                          target_clients: Optional[List[str]] = None):
    """éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é…ä¿¡"""
    try:
        # Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦é…ä¿¡
        encoded_audio = base64.b64encode(audio_data).decode('utf-8')
        
        payload = {
            'audio_data': encoded_audio,
            'metadata': audio_metadata,
            'timestamp': audio_metadata.get('timestamp', ''),
            'format': 'audio/wav',
            'encoding': 'base64'
        }
        
        # é…ä¿¡å¯¾è±¡ã®æ±ºå®š
        if target_clients:
            for client_id in target_clients:
                if client_id in connected_clients:
                    socketio.emit('audio_stream', payload, room=client_id)
        else:
            socketio.emit('audio_stream', payload)
            
    except Exception as e:
        logger.error(f"Audio stream broadcast error: {e}")
```

**ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°API**

```python
# backend/src/web/routes/tts_streaming_routes.py
@tts_streaming_bp.route('/stream-audio', methods=['POST'])
def stream_audio():
    """WebSocketçµŒç”±ã§ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ éŸ³å£°é…ä¿¡"""
    try:
        data = request.get_json()
        text = data.get('text')
        emotion = data.get('emotion', 'neutral')
        broadcast_all = data.get('broadcast_all', False)
        
        # éŸ³å£°åˆæˆå®Ÿè¡Œ
        audio_result = tts_service.synthesize_text_fast(
            text=text, emotion=emotion
        )
        
        # ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é…ä¿¡
        audio_file_path = audio_result.get('file_path')
        if audio_file_path:
            queue_audio_for_streaming(audio_file_path, {
                'type': 'real_time_synthesis',
                'text': text,
                'emotion': emotion,
                'broadcast_all': broadcast_all
            })
        
        return jsonify({'success': True, 'audio_file_id': audio_result['audio_file_id']})
    except Exception as e:
        return jsonify({'error': 'synthesis_failed'}), 500
```

=== ğŸ­ æ„Ÿæƒ…åˆ¶å¾¡ã¨ãƒœã‚¤ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ‹ãƒ³ã‚°

```python
# backend/src/services/tts/emotion_manager.py
class EmotionManager:
    def apply_emotion(self, audio_data: AudioData, emotion: str) -> AudioData:
        """æ„Ÿæƒ…ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’éŸ³å£°ã«é©ç”¨"""
        emotion_params = self.get_emotion_parameters(emotion)
        
        # ãƒ”ãƒƒãƒèª¿æ•´
        if 'pitch_shift' in emotion_params:
            audio_data = self._adjust_pitch(audio_data, emotion_params['pitch_shift'])
        
        # é€Ÿåº¦èª¿æ•´
        if 'speed_factor' in emotion_params:
            audio_data = self._adjust_speed(audio_data, emotion_params['speed_factor'])
        
        # éŸ³é‡èª¿æ•´
        if 'volume_factor' in emotion_params:
            audio_data = self._adjust_volume(audio_data, emotion_params['volume_factor'])
        
        return audio_data
```

== ğŸ“± å¤–éƒ¨APIé€£æº

=== ğŸ“ LINE APIçµ±åˆ

```python
# backend/src/services/communication/line_service.py
class LineService:
    def __init__(self, config_manager: ConfigManager):
        self.enabled = config_manager.get('line.enabled', False)
        self.token = config_manager.get('line.token')
        self.user_id = config_manager.get('line.user_id')
        
        if self.enabled and self.token:
            configuration = Configuration(access_token=self.token)
            self.api_client = ApiClient(configuration)
            self.messaging_api = MessagingApi(self.api_client)

    def send_message(self, message):
        """LINE ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡"""
        if not self.enabled or not self.messaging_api:
            return
            
        try:
            request = PushMessageRequest(
                to=self.user_id,
                messages=[TextMessage(text=message)]
            )
            self.messaging_api.push_message(request)
            logger.info("LINE message sent successfully")
        except Exception as e:
            logger.error(f"LINE message sending error: {e}")
```

=== ğŸ“§ ãƒãƒ«ãƒãƒãƒ£ãƒãƒ«é€šçŸ¥

[mermaid]
....
flowchart TD
    START[ã‚¢ãƒ©ãƒ¼ãƒˆç™ºç”Ÿ] --> EVAL[é€šçŸ¥ãƒãƒ£ãƒãƒ«è©•ä¾¡]
    
    EVAL --> URGENT{ç·Šæ€¥åº¦åˆ¤å®š}
    
    URGENT -->|é«˜| MULTI[è¤‡æ•°ãƒãƒ£ãƒãƒ«åŒæ™‚é…ä¿¡]
    URGENT -->|ä¸­| PREF[è¨­å®šå„ªå…ˆãƒãƒ£ãƒãƒ«]
    URGENT -->|ä½| LOG[ãƒ­ã‚°è¨˜éŒ²ã®ã¿]
    
    MULTI --> TTS_CH[TTSéŸ³å£°]
    MULTI --> WS_CH[WebSocket]
    MULTI --> LINE_CH[LINEé€šçŸ¥]
    
    PREF --> SINGLE[å˜ä¸€ãƒãƒ£ãƒãƒ«é…ä¿¡]
    
    TTS_CH --> RESULT[é…ä¿¡çµæœè¨˜éŒ²]
    WS_CH --> RESULT
    LINE_CH --> RESULT
    SINGLE --> RESULT
    LOG --> RESULT
    
    RESULT --> END[å‡¦ç†å®Œäº†]
....

== âš™ï¸ è¨­å®šç®¡ç†ã¨æœ€é©åŒ–

=== ğŸ”§ é€šä¿¡è¨­å®šä»•æ§˜

```yaml
# config/config.yaml - é€šä¿¡ã‚·ã‚¹ãƒ†ãƒ è¨­å®šä¾‹
communication:
  websocket:
    cors_allowed_origins: "*"
    ping_timeout: 60
    ping_interval: 25
    max_http_buffer_size: 1000000
    
  alerts:
    enabled: true
    default_channels: ["tts_voice", "websocket"]
    severity_thresholds:
      absence_alert: 300  # 5åˆ†
      smartphone_alert: 180  # 3åˆ†
    
  line_api:
    enabled: true
    token: "YOUR_LINE_NOTIFY_TOKEN"
    user_id: "YOUR_LINE_USER_ID"
    rate_limit: 1000  # messages per hour
    
  tts:
    default_voice: "neutral"
    default_emotion: "neutral"
    audio_format: "wav"
    sample_rate: 22050
    streaming_enabled: true
    
  audio_streaming:
    buffer_size: 8192
    max_clients: 50
    compression_enabled: true
```

=== ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

```python
# backend/src/web/routes/realtime_analysis_routes.py
@realtime_analysis_bp.route('/streaming-status', methods=['GET'])
def get_streaming_status():
    """ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†çŠ¶æ…‹å–å¾—"""
    try:
        connected_clients = get_connected_clients_count()
        
        response = {
            'streaming_system': {
                'status': 'active' if connected_clients > 0 else 'idle',
                'connected_clients': connected_clients,
                'active_streams': 0,
                'total_streamed': 0
            },
            'services': {
                'tts_service': 'available' if tts_service else 'unavailable',
                'websocket': 'active'
            }
        }
        
        return jsonify(response)
    except Exception as e:
        return jsonify({'error': 'internal_error'}), 500
```

== ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

=== ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

**èªè¨¼ãƒ»èªå¯**
- WebSocketæ¥ç¶šæ™‚ã®ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
- APIå‘¼ã³å‡ºã—ã®èªè¨¼ãƒ˜ãƒƒãƒ€ãƒ¼ç¢ºèª
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«ã‚ˆã‚‹ä¸æ­£åˆ©ç”¨é˜²æ­¢

**ãƒ‡ãƒ¼ã‚¿ä¿è­·**
- éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ™‚çš„ä¿å­˜ã¨è‡ªå‹•å‰Šé™¤
- å€‹äººæƒ…å ±ã‚’å«ã‚€é€šçŸ¥ã®æš—å·åŒ–
- é€šä¿¡ãƒ­ã‚°ã®åŒ¿ååŒ–

=== âš ï¸ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æˆ¦ç•¥

```python
# backend/src/utils/exceptions.py
class CommunicationError(Exception):
    """é€šä¿¡é–¢é€£ã®åŸºåº•ä¾‹å¤–"""
    pass

class WebSocketError(CommunicationError):
    """WebSocketé€šä¿¡ã‚¨ãƒ©ãƒ¼"""
    pass

class AudioStreamError(CommunicationError):
    """éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚¨ãƒ©ãƒ¼"""  
    pass

class NotificationDeliveryError(CommunicationError):
    """é€šçŸ¥é…ä¿¡ã‚¨ãƒ©ãƒ¼"""
    pass
```

**å¾©æ—§å‡¦ç†ãƒ‘ã‚¿ãƒ¼ãƒ³**

[mermaid]
....
flowchart TD
    ERROR[ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ] --> TYPE{ã‚¨ãƒ©ãƒ¼ç¨®åˆ¥åˆ¤å®š}
    
    TYPE -->|WebSocketåˆ‡æ–­| RECONNECT[è‡ªå‹•å†æ¥ç¶š]
    TYPE -->|éŸ³å£°åˆæˆå¤±æ•—| FALLBACK[ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯éŸ³å£°]
    TYPE -->|LINE API ã‚¨ãƒ©ãƒ¼| RETRY[ãƒªãƒˆãƒ©ã‚¤æ©Ÿæ§‹]
    TYPE -->|ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼| LOG[ãƒ­ã‚°è¨˜éŒ²]
    
    RECONNECT --> SUCCESS{å†æ¥ç¶šæˆåŠŸ}
    SUCCESS -->|Yes| RESUME[ã‚µãƒ¼ãƒ“ã‚¹å¾©æ—§]
    SUCCESS -->|No| MANUAL[æ‰‹å‹•ä»‹å…¥è¦æ±‚]
    
    FALLBACK --> CACHE[ã‚­ãƒ£ãƒƒã‚·ãƒ¥éŸ³å£°å†ç”Ÿ]
    RETRY --> LIMIT{ãƒªãƒˆãƒ©ã‚¤åˆ¶é™}
    LIMIT -->|æœªé”| WAIT[å¾…æ©Ÿå¾Œå†è©¦è¡Œ]
    LIMIT -->|è¶…é| DISABLE[æ©Ÿèƒ½ä¸€æ™‚ç„¡åŠ¹]
    
    RESUME --> END[æ­£å¸¸é‹ç”¨ç¶™ç¶š]
    CACHE --> END
    WAIT --> RETRY
    DISABLE --> END
    MANUAL --> END
    LOG --> END
....

== ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

=== ğŸ”¬ å˜ä½“ãƒ†ã‚¹ãƒˆ

```python
# tests/test_communication_system.py
import pytest
from unittest.mock import MagicMock, patch
from services.communication.alert_service import AlertService

class TestAlertService:
    def test_trigger_absence_alert(self):
        """ä¸åœ¨ã‚¢ãƒ©ãƒ¼ãƒˆã®ãƒ†ã‚¹ãƒˆ"""
        config_manager = MagicMock()
        alert_service = AlertService(config_manager)
        
        with patch.object(alert_service, '_send_line_notify') as mock_line:
            alert_service.trigger_absence_alert(300)
            mock_line.assert_called_once()
            
    def test_websocket_broadcast(self):
        """WebSocketé…ä¿¡ã®ãƒ†ã‚¹ãƒˆ"""
        from web.websocket import broadcast_status
        
        test_status = {'personDetected': True, 'absenceTime': 0}
        
        with patch('web.websocket.socketio') as mock_socketio:
            broadcast_status(test_status)
            mock_socketio.emit.assert_called_with('status_update', test_status)
```

=== ğŸŒ çµ±åˆãƒ†ã‚¹ãƒˆ

```python
# tests/test_integration_communication.py
def test_end_to_end_alert_flow():
    """ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã‚¢ãƒ©ãƒ¼ãƒˆãƒ•ãƒ­ãƒ¼ã®ãƒ†ã‚¹ãƒˆ"""
    # 1. æ¤œå‡ºã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿ
    # 2. ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
    # 3. è¤‡æ•°ãƒãƒ£ãƒãƒ«é…ä¿¡
    # 4. é…ä¿¡çµæœæ¤œè¨¼
    pass

def test_websocket_audio_streaming():
    """éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã®çµ±åˆãƒ†ã‚¹ãƒˆ"""
    # 1. TTSéŸ³å£°åˆæˆ
    # 2. WebSocketé…ä¿¡
    # 3. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå—ä¿¡ç¢ºèª
    pass
```

== ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ»ãƒªã‚½ãƒ¼ã‚¹

=== ğŸ“– å‚ç…§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

* **<<websocket-api>>**: WebSocket APIè©³ç´°ä»•æ§˜
* **<<rest-api-reference>>**: REST APIé€£æºä»•æ§˜
* **<<system-design>>**: ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“è¨­è¨ˆ
* **<<configuration-guide>>**: è¨­å®šè©³ç´°ã‚¬ã‚¤ãƒ‰

=== ğŸ”— å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹

* **Flask-SocketIO**: https://flask-socketio.readthedocs.io/
* **LINE Messaging API**: https://developers.line.biz/ja/docs/messaging-api/
* **Socket.IO Protocol**: https://socket.io/docs/v4/socket-io-protocol/
* **Web Audio API**: https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API

=== ğŸ› ï¸ é–‹ç™ºæ”¯æ´ãƒ„ãƒ¼ãƒ«

```bash
# WebSocketãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
npm install -g wscat
wscat -c ws://localhost:8000/socket.io/?EIO=4&transport=websocket

# LINE API ãƒ†ã‚¹ãƒˆ
curl -X POST https://notify-api.line.me/api/notify \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d "message=Test Message"

# TTSéŸ³å£°åˆæˆãƒ†ã‚¹ãƒˆ
curl -X POST http://localhost:8000/api/tts/synthesis \
  -H "Content-Type: application/json" \
  -d '{"text": "ãƒ†ã‚¹ãƒˆéŸ³å£°", "emotion": "neutral"}'
```

---

**ğŸ“ Contact**: team@kanshichan.dev +
**ğŸ”— Repository**: https://github.com/kanshichan/backend +
**ğŸ“… Last Updated**: 2024-12-27 