= ğŸš€ ç›£è¦–ã¡ã‚ƒã‚“(KanshiChan) æ‹¡å¼µãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚¬ã‚¤ãƒ‰
:toc: left
:toc-title: ç›®æ¬¡
:toclevels: 3
:numbered:
:source-highlighter: highlight.js
:icons: font
:doctype: book
:author: KanshiChan Development Team
:email: team@kanshichan.dev
:revnumber: 1.0
:revdate: {docdate}
:experimental:

[NOTE]
====
ğŸ“‹ **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæƒ…å ±**

* **ä½œæˆè€…**: KanshiChan Development Team
* **æœ€çµ‚æ›´æ–°æ—¥**: {docdate}
* **å¯¾è±¡èª­è€…**: é–‹ç™ºè€…ã€ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ‹…å½“è€…
* **å‰æçŸ¥è­˜**: Python/Flaské–‹ç™ºã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã€APIè¨­è¨ˆ
* **é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: <<system-design.adoc>>, <<development-guide.adoc>>, <<backend-architecture.adoc>>
====

== ğŸ“– æ¦‚è¦

ç›£è¦–ã¡ã‚ƒã‚“ï¼ˆKanshiChanï¼‰ã‚·ã‚¹ãƒ†ãƒ ã®æ©Ÿèƒ½æ‹¡å¼µã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã®ãŸã‚ã®é–‹ç™ºè€…ã‚¬ã‚¤ãƒ‰ã§ã™ã€‚
ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã€ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–‹ç™ºã€æ–°æ©Ÿèƒ½è¿½åŠ ã®åŒ…æ‹¬çš„ãªæŒ‡é‡ã‚’æä¾›ã—ã¾ã™ã€‚

=== ğŸ¯ æ‹¡å¼µç›®æ¨™

* **ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åŒ–**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‹ã§æŸ”è»Ÿãªæ©Ÿèƒ½æ‹¡å¼µ
* **äº’æ›æ€§ç¶­æŒ**: æ—¢å­˜æ©Ÿèƒ½ã¸ã®å½±éŸ¿ãªã—
* **æ¨™æº–åŒ–**: ä¸€è²«ã—ãŸæ‹¡å¼µãƒ‘ã‚¿ãƒ¼ãƒ³
* **æ€§èƒ½ä¿æŒ**: æ‹¡å¼µã«ã‚ˆã‚‹æ€§èƒ½åŠ£åŒ–ã®æœ€å°åŒ–

== ğŸ—ï¸ æ‹¡å¼µã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

=== ã‚·ã‚¹ãƒ†ãƒ æ‹¡å¼µå…¨ä½“æ§‹æˆ

[mermaid]
....
graph TB
    subgraph "Core System"
        CORE[KanshiChan Core<br/>åŸºå¹¹ã‚·ã‚¹ãƒ†ãƒ ]
        API[REST/WebSocket API<br/>æ¨™æº–ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹]
        DB[(Database<br/>PostgreSQL)]
    end
    
    subgraph "Extension Framework"
        PLUGIN[Plugin Manager<br/>ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†]
        HOOK[Hook System<br/>ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ãƒƒã‚¯]
        CONFIG[Extension Config<br/>æ‹¡å¼µè¨­å®š]
    end
    
    subgraph "Built-in Extensions"
        AI[AI Detection<br/>YOLO + MediaPipe]
        TTS[TTS Service<br/>éŸ³å£°åˆæˆ]
        BEHAVIOR[Behavior Analytics<br/>è¡Œå‹•åˆ†æ]
    end
    
    subgraph "Custom Extensions"
        CUSTOM1[Custom Plugin 1<br/>ã‚«ã‚¹ã‚¿ãƒ AIæ©Ÿèƒ½]
        CUSTOM2[Custom Plugin 2<br/>å¤–éƒ¨APIé€£æº]
        CUSTOM3[Custom Plugin 3<br/>ç‹¬è‡ªåˆ†ææ©Ÿèƒ½]
    end
    
    subgraph "Extension Points"
        EP1[Detection Hook<br/>æ¤œå‡ºå‡¦ç†æ‹¡å¼µ]
        EP2[Analysis Hook<br/>åˆ†æå‡¦ç†æ‹¡å¼µ]
        EP3[Notification Hook<br/>é€šçŸ¥å‡¦ç†æ‹¡å¼µ]
        EP4[API Hook<br/>APIå‡¦ç†æ‹¡å¼µ]
    end
    
    CORE --> API
    CORE --> DB
    
    PLUGIN --> HOOK
    PLUGIN --> CONFIG
    
    AI --> EP1
    TTS --> EP3
    BEHAVIOR --> EP2
    
    CUSTOM1 --> EP1
    CUSTOM2 --> EP4
    CUSTOM3 --> EP2
    
    HOOK --> EP1
    HOOK --> EP2
    HOOK --> EP3
    HOOK --> EP4
....

== ğŸ”§ æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆä¸€è¦§

=== ä¸»è¦æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ

**æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ æ‹¡å¼µ**
```python
# src/extensions/detection/__init__.py
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional

class DetectionExtension(ABC):
    """æ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ æ‹¡å¼µåŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    @abstractmethod
    def get_name(self) -> str:
        """æ‹¡å¼µåã‚’å–å¾—"""
        pass
        
    @abstractmethod
    def get_version(self) -> str:
        """æ‹¡å¼µãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—"""
        pass
        
    @abstractmethod
    def initialize(self, config: Dict[str, Any]) -> bool:
        """æ‹¡å¼µåˆæœŸåŒ–"""
        pass
        
    @abstractmethod
    def detect(self, image_data: bytes, metadata: Dict[str, Any]) -> List[Dict[str, Any]]:
        """æ¤œå‡ºå‡¦ç†å®Ÿè¡Œ"""
        pass
        
    @abstractmethod
    def cleanup(self) -> None:
        """æ‹¡å¼µçµ‚äº†å‡¦ç†"""
        pass

# ã‚«ã‚¹ã‚¿ãƒ æ¤œå‡ºæ‹¡å¼µä¾‹
class CustomObjectDetector(DetectionExtension):
    """ã‚«ã‚¹ã‚¿ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¤œå‡ºæ‹¡å¼µ"""
    
    def __init__(self):
        self.model = None
        self.config = None
        
    def get_name(self) -> str:
        return "custom_object_detector"
        
    def get_version(self) -> str:
        return "1.0.0"
        
    def initialize(self, config: Dict[str, Any]) -> bool:
        """ã‚«ã‚¹ã‚¿ãƒ ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–"""
        try:
            self.config = config
            model_path = config.get('model_path')
            
            # ã‚«ã‚¹ã‚¿ãƒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
            self.model = self._load_custom_model(model_path)
            
            logger.info(f"Custom detector initialized: {model_path}")
            return True
            
        except Exception as e:
            logger.error(f"Custom detector initialization failed: {e}")
            return False
            
    def detect(self, image_data: bytes, metadata: Dict[str, Any]) -> List[Dict[str, Any]]:
        """ã‚«ã‚¹ã‚¿ãƒ æ¤œå‡ºå‡¦ç†"""
        if not self.model:
            return []
            
        try:
            # ç”»åƒå‰å‡¦ç†
            image = self._preprocess_image(image_data)
            
            # æ¨è«–å®Ÿè¡Œ
            predictions = self.model.predict(image)
            
            # çµæœå¤‰æ›
            detections = self._convert_predictions(predictions)
            
            return detections
            
        except Exception as e:
            logger.error(f"Custom detection failed: {e}")
            return []
            
    def _load_custom_model(self, model_path: str):
        """ã‚«ã‚¹ã‚¿ãƒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿"""
        # å®Ÿè£…ä¾‹: TensorFlow, PyTorch, ONNXãªã©
        import onnxruntime as ort
        return ort.InferenceSession(model_path)
```

**åˆ†æã‚·ã‚¹ãƒ†ãƒ æ‹¡å¼µ**
```python
# src/extensions/analysis/__init__.py
class AnalysisExtension(ABC):
    """åˆ†æã‚·ã‚¹ãƒ†ãƒ æ‹¡å¼µåŸºåº•ã‚¯ãƒ©ã‚¹"""
    
    @abstractmethod
    def analyze(self, behavior_data: List[Dict[str, Any]], 
                user_context: Dict[str, Any]) -> Dict[str, Any]:
        """åˆ†æå‡¦ç†å®Ÿè¡Œ"""
        pass

class CustomBehaviorAnalyzer(AnalysisExtension):
    """ã‚«ã‚¹ã‚¿ãƒ è¡Œå‹•åˆ†ææ‹¡å¼µ"""
    
    def __init__(self):
        self.ml_model = None
        
    def initialize(self, config: Dict[str, Any]) -> bool:
        """æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–"""
        try:
            from sklearn.ensemble import IsolationForest
            
            # ç•°å¸¸æ¤œçŸ¥ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–
            self.ml_model = IsolationForest(
                contamination=config.get('contamination', 0.1),
                random_state=42
            )
            
            # äº‹å‰å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯èª­ã¿è¾¼ã¿
            model_data_path = config.get('model_data_path')
            if model_data_path:
                self._load_pretrained_model(model_data_path)
                
            return True
            
        except Exception as e:
            logger.error(f"Custom analyzer initialization failed: {e}")
            return False
            
    def analyze(self, behavior_data: List[Dict[str, Any]], 
                user_context: Dict[str, Any]) -> Dict[str, Any]:
        """ã‚«ã‚¹ã‚¿ãƒ åˆ†æå‡¦ç†"""
        
        # ç‰¹å¾´é‡æŠ½å‡º
        features = self._extract_features(behavior_data, user_context)
        
        # ç•°å¸¸æ¤œçŸ¥
        anomaly_score = self._detect_anomalies(features)
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
        patterns = self._analyze_patterns(behavior_data)
        
        # å€‹äººåŒ–æ¨å¥¨
        recommendations = self._generate_recommendations(
            features, anomaly_score, patterns, user_context
        )
        
        return {
            'anomaly_score': anomaly_score,
            'behavior_patterns': patterns,
            'recommendations': recommendations,
            'analysis_timestamp': datetime.now().isoformat(),
            'analyzer_version': self.get_version()
        }
        
    def _extract_features(self, behavior_data: List[Dict[str, Any]], 
                         user_context: Dict[str, Any]) -> np.ndarray:
        """ç‰¹å¾´é‡æŠ½å‡º"""
        features = []
        
        # æ™‚ç³»åˆ—ç‰¹å¾´é‡
        if behavior_data:
            # ä½œæ¥­æ™‚é–“ãƒ‘ã‚¿ãƒ¼ãƒ³
            work_hours = [self._extract_hour(entry) for entry in behavior_data]
            features.extend([
                np.mean(work_hours),
                np.std(work_hours),
                len(set(work_hours))  # ä½œæ¥­æ™‚é–“å¸¯ã®å¤šæ§˜æ€§
            ])
            
            # é›†ä¸­åº¦ç‰¹å¾´é‡
            focus_scores = [entry.get('focus_score', 0) for entry in behavior_data]
            features.extend([
                np.mean(focus_scores),
                np.std(focus_scores),
                np.min(focus_scores),
                np.max(focus_scores)
            ])
            
            # ä¸­æ–­å›æ•°ãƒ»ãƒ‘ã‚¿ãƒ¼ãƒ³
            interruptions = [entry.get('interruption_count', 0) for entry in behavior_data]
            features.extend([
                np.sum(interruptions),
                np.mean(interruptions),
                len([i for i in interruptions if i > 0])  # ä¸­æ–­ç™ºç”Ÿæ—¥æ•°
            ])
            
        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç‰¹å¾´é‡
        features.extend([
            user_context.get('productivity_baseline', 0.5),
            user_context.get('stress_level', 0.5),
            user_context.get('workload_intensity', 0.5)
        ])
        
        return np.array(features).reshape(1, -1)
```

=== ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

**ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼**
```python
# src/core/plugin_manager.py
import importlib
import inspect
from pathlib import Path
from typing import Dict, List, Type, Any, Optional

class PluginManager:
    """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ """
    
    def __init__(self, plugin_directories: List[str]):
        self.plugin_directories = plugin_directories
        self.loaded_plugins: Dict[str, Any] = {}
        self.plugin_configs: Dict[str, Dict[str, Any]] = {}
        self.hooks: Dict[str, List[callable]] = {}
        
    def discover_plugins(self) -> List[str]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è‡ªå‹•ç™ºè¦‹"""
        discovered_plugins = []
        
        for plugin_dir in self.plugin_directories:
            plugin_path = Path(plugin_dir)
            if not plugin_path.exists():
                continue
                
            for plugin_file in plugin_path.glob("*.py"):
                if plugin_file.name.startswith("__"):
                    continue
                    
                plugin_name = plugin_file.stem
                discovered_plugins.append(plugin_name)
                
        return discovered_plugins
        
    def load_plugin(self, plugin_name: str, config: Optional[Dict[str, Any]] = None) -> bool:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³èª­ã¿è¾¼ã¿"""
        try:
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
            for plugin_dir in self.plugin_directories:
                plugin_path = Path(plugin_dir) / f"{plugin_name}.py"
                if plugin_path.exists():
                    spec = importlib.util.spec_from_file_location(plugin_name, plugin_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)
                    
                    # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹æ¤œç´¢
                    plugin_class = self._find_plugin_class(module)
                    if not plugin_class:
                        logger.warning(f"No plugin class found in {plugin_name}")
                        return False
                        
                    # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
                    plugin_instance = plugin_class()
                    
                    # è¨­å®šé©ç”¨
                    plugin_config = config or self.plugin_configs.get(plugin_name, {})
                    if hasattr(plugin_instance, 'initialize'):
                        if not plugin_instance.initialize(plugin_config):
                            logger.error(f"Plugin initialization failed: {plugin_name}")
                            return False
                            
                    # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç™»éŒ²
                    self.loaded_plugins[plugin_name] = plugin_instance
                    
                    # ãƒ•ãƒƒã‚¯ç™»éŒ²
                    self._register_plugin_hooks(plugin_name, plugin_instance)
                    
                    logger.info(f"Plugin loaded successfully: {plugin_name}")
                    return True
                    
        except Exception as e:
            logger.error(f"Plugin loading failed: {plugin_name}: {e}")
            return False
            
        logger.warning(f"Plugin not found: {plugin_name}")
        return False
        
    def unload_plugin(self, plugin_name: str) -> bool:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰"""
        if plugin_name not in self.loaded_plugins:
            return False
            
        try:
            plugin_instance = self.loaded_plugins[plugin_name]
            
            # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
            if hasattr(plugin_instance, 'cleanup'):
                plugin_instance.cleanup()
                
            # ãƒ•ãƒƒã‚¯è§£é™¤
            self._unregister_plugin_hooks(plugin_name)
            
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å‰Šé™¤
            del self.loaded_plugins[plugin_name]
            
            logger.info(f"Plugin unloaded: {plugin_name}")
            return True
            
        except Exception as e:
            logger.error(f"Plugin unloading failed: {plugin_name}: {e}")
            return False
            
    def execute_hook(self, hook_name: str, *args, **kwargs) -> List[Any]:
        """ãƒ•ãƒƒã‚¯å®Ÿè¡Œ"""
        results = []
        
        if hook_name in self.hooks:
            for hook_func in self.hooks[hook_name]:
                try:
                    result = hook_func(*args, **kwargs)
                    results.append(result)
                except Exception as e:
                    logger.error(f"Hook execution failed: {hook_name}: {e}")
                    
        return results
        
    def _find_plugin_class(self, module) -> Optional[Type]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹æ¤œç´¢"""
        for name, obj in inspect.getmembers(module):
            if inspect.isclass(obj) and hasattr(obj, 'get_name'):
                return obj
        return None
        
    def _register_plugin_hooks(self, plugin_name: str, plugin_instance: Any):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ•ãƒƒã‚¯ç™»éŒ²"""
        hook_methods = [
            'on_detection_start',
            'on_detection_complete', 
            'on_analysis_start',
            'on_analysis_complete',
            'on_notification_trigger'
        ]
        
        for hook_method in hook_methods:
            if hasattr(plugin_instance, hook_method):
                if hook_method not in self.hooks:
                    self.hooks[hook_method] = []
                self.hooks[hook_method].append(getattr(plugin_instance, hook_method))
```

=== ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆé–‹ç™º

**ã‚«ã‚¹ã‚¿ãƒ APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä½œæˆ**
```python
# src/extensions/api_endpoints/custom_endpoints.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity

# ã‚«ã‚¹ã‚¿ãƒ Blueprintä½œæˆ
custom_api = Blueprint('custom_api', __name__, url_prefix='/api/v1/custom')

class CustomAPIExtension:
    """ã‚«ã‚¹ã‚¿ãƒ APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ‹¡å¼µ"""
    
    def __init__(self, app, plugin_manager):
        self.app = app
        self.plugin_manager = plugin_manager
        self.setup_routes()
        
    def setup_routes(self):
        """ã‚«ã‚¹ã‚¿ãƒ ãƒ«ãƒ¼ãƒˆè¨­å®š"""
        
        @custom_api.route('/advanced-analysis', methods=['POST'])
        @jwt_required()
        def advanced_analysis():
            """é«˜åº¦åˆ†æAPI"""
            try:
                user_id = get_jwt_identity()
                data = request.get_json()
                
                # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œè¨¼
                if not self._validate_analysis_params(data):
                    return jsonify({'error': 'Invalid parameters'}), 400
                    
                # ã‚«ã‚¹ã‚¿ãƒ åˆ†æå®Ÿè¡Œ
                analysis_result = self._execute_advanced_analysis(user_id, data)
                
                # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ•ãƒƒã‚¯å®Ÿè¡Œ
                self.plugin_manager.execute_hook(
                    'on_advanced_analysis_complete',
                    user_id, analysis_result
                )
                
                return jsonify({
                    'status': 'success',
                    'analysis': analysis_result,
                    'timestamp': datetime.now().isoformat()
                })
                
            except Exception as e:
                logger.error(f"Advanced analysis failed: {e}")
                return jsonify({'error': 'Analysis failed'}), 500
                
        @custom_api.route('/ai-model-switch', methods=['POST'])
        @jwt_required()
        def switch_ai_model():
            """AIãƒ¢ãƒ‡ãƒ«å‹•çš„åˆ‡ã‚Šæ›¿ãˆ"""
            try:
                user_id = get_jwt_identity()
                data = request.get_json()
                
                model_name = data.get('model_name')
                model_config = data.get('config', {})
                
                # ãƒ¢ãƒ‡ãƒ«åˆ‡ã‚Šæ›¿ãˆå®Ÿè¡Œ
                success = self._switch_detection_model(user_id, model_name, model_config)
                
                if success:
                    return jsonify({
                        'status': 'success',
                        'message': f'Switched to model: {model_name}'
                    })
                else:
                    return jsonify({'error': 'Model switch failed'}), 500
                    
            except Exception as e:
                logger.error(f"Model switch failed: {e}")
                return jsonify({'error': 'Model switch failed'}), 500
        
        # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«Blueprintç™»éŒ²
        self.app.register_blueprint(custom_api)
        
    def _validate_analysis_params(self, data: Dict[str, Any]) -> bool:
        """åˆ†æãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¤œè¨¼"""
        required_fields = ['analysis_type', 'time_range']
        return all(field in data for field in required_fields)
        
    def _execute_advanced_analysis(self, user_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """é«˜åº¦åˆ†æå®Ÿè¡Œ"""
        analysis_type = params['analysis_type']
        
        # åˆ†æã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‡¦ç†åˆ†å²
        if analysis_type == 'productivity_optimization':
            return self._analyze_productivity_optimization(user_id, params)
        elif analysis_type == 'attention_pattern':
            return self._analyze_attention_patterns(user_id, params)
        elif analysis_type == 'distraction_prediction':
            return self._predict_distractions(user_id, params)
        else:
            raise ValueError(f"Unknown analysis type: {analysis_type}")
```

== ğŸ”„ æ–°æ©Ÿèƒ½è¿½åŠ æ‰‹é †

=== æ¨™æº–è¿½åŠ ãƒ—ãƒ­ã‚»ã‚¹

**æ–°æ©Ÿèƒ½é–‹ç™ºãƒ•ãƒ­ãƒ¼**
[mermaid]
....
flowchart TD
    START[æ–°æ©Ÿèƒ½è¦ä»¶å®šç¾©] --> DESIGN[è¨­è¨ˆãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¤œè¨]
    DESIGN --> PLUGIN_CHECK{ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åŒ–å¯èƒ½?}
    
    PLUGIN_CHECK -->|Yes| PLUGIN_DEV[ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™º]
    PLUGIN_CHECK -->|No| CORE_DEV[ã‚³ã‚¢æ©Ÿèƒ½é–‹ç™º]
    
    PLUGIN_DEV --> PLUGIN_TEST[ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆ]
    CORE_DEV --> CORE_TEST[ã‚³ã‚¢æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ]
    
    PLUGIN_TEST --> INTEGRATION[çµ±åˆãƒ†ã‚¹ãƒˆ]
    CORE_TEST --> INTEGRATION
    
    INTEGRATION --> COMPATIBILITY[äº’æ›æ€§ãƒã‚§ãƒƒã‚¯]
    COMPATIBILITY --> PASS{ãƒ†ã‚¹ãƒˆåˆæ ¼?}
    
    PASS -->|No| DEBUG[ãƒ‡ãƒãƒƒã‚°ãƒ»ä¿®æ­£]
    DEBUG --> INTEGRATION
    
    PASS -->|Yes| DOCUMENTATION[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°]
    DOCUMENTATION --> DEPLOYMENT[ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ]
    DEPLOYMENT --> MONITORING[ç›£è¦–ãƒ»è©•ä¾¡]
    
    MONITORING --> END[æ©Ÿèƒ½ãƒªãƒªãƒ¼ã‚¹å®Œäº†]
....

**æ–°æ©Ÿèƒ½è¿½åŠ ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**
```yaml
# new_feature_checklist.yml
feature_development:
  planning:
    - name: "è¦ä»¶å®šç¾©å®Œäº†"
      required: true
      description: "æ©Ÿèƒ½è¦ä»¶ã¨éæ©Ÿèƒ½è¦ä»¶ã®æ˜ç¢ºåŒ–"
      
    - name: "è¨­è¨ˆãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†" 
      required: true
      description: "ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆ"
      
    - name: "äº’æ›æ€§å½±éŸ¿è©•ä¾¡"
      required: true
      description: "æ—¢å­˜æ©Ÿèƒ½ã¸ã®å½±éŸ¿è©•ä¾¡ã¨å¯¾ç­–"
      
  implementation:
    - name: "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åŒ–æ¤œè¨"
      required: true
      description: "ã‚³ã‚¢æ©Ÿèƒ½ã¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã®é©åˆ‡ãªåˆ†é›¢"
      
    - name: "ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè£…"
      required: true
      description: "ä¾‹å¤–å‡¦ç†ã¨éšœå®³æ™‚ã®å‹•ä½œå®šç¾©"
      
    - name: "ãƒ­ã‚°ãƒ»ç›£è¦–é …ç›®è¿½åŠ "
      required: true
      description: "é‹ç”¨ç›£è¦–ã®ãŸã‚ã®ãƒ­ã‚°å‡ºåŠ›"
      
    - name: "è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–"
      required: true
      description: "è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã‚‹å‹•ä½œåˆ¶å¾¡"
      
  testing:
    - name: "å˜ä½“ãƒ†ã‚¹ãƒˆå®Ÿè£…"
      required: true
      coverage_threshold: 80
      
    - name: "çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè£…"
      required: true
      description: "æ—¢å­˜æ©Ÿèƒ½ã¨ã®é€£æºãƒ†ã‚¹ãƒˆ"
      
    - name: "æ€§èƒ½ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"
      required: true
      description: "æ–°æ©Ÿèƒ½è¿½åŠ ã«ã‚ˆã‚‹æ€§èƒ½å½±éŸ¿è©•ä¾¡"
      
    - name: "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ"
      required: true
      description: "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã®ç¢ºèª"
      
  documentation:
    - name: "API ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°"
      required: true
      description: "æ–°è¦APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®æ–‡æ›¸åŒ–"
      
    - name: "è¨­å®šã‚¬ã‚¤ãƒ‰æ›´æ–°"
      required: true
      description: "æ–°è¦è¨­å®šé …ç›®ã®èª¬æ˜è¿½åŠ "
      
    - name: "ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ä½œæˆ"
      required: true
      description: "ä½¿ç”¨ä¾‹ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹"
      
  deployment:
    - name: "ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ‰‹é †"
      required: true
      description: "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒå¤‰æ›´æ™‚ã®æ‰‹é †"
      
    - name: "ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †"
      required: true
      description: "å•é¡Œç™ºç”Ÿæ™‚ã®å¾©æ—§æ‰‹é †"
      
    - name: "ç›£è¦–é …ç›®è¨­å®š"
      required: true
      description: "æ–°æ©Ÿèƒ½ã®ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š"
```

=== äº’æ›æ€§ä¿æŒæˆ¦ç•¥

**API ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°æˆ¦ç•¥**
```python
# src/api/versioning.py
from flask import Blueprint, request, jsonify
from typing import Dict, Any, Optional

class APIVersionManager:
    """APIãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†"""
    
    def __init__(self):
        self.supported_versions = ['v1', 'v2']
        self.default_version = 'v1'
        self.deprecated_versions = []
        
    def get_api_version(self, request) -> str:
        """ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ã‚‰APIãƒãƒ¼ã‚¸ãƒ§ãƒ³å–å¾—"""
        
        # ãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³å–å¾—
        version = request.headers.get('API-Version')
        if version and self._is_supported_version(version):
            return version
            
        # URLãƒ‘ã‚¹ã‹ã‚‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³å–å¾—
        path_parts = request.path.split('/')
        if len(path_parts) > 2 and path_parts[2].startswith('v'):
            version = path_parts[2]
            if self._is_supported_version(version):
                return version
                
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒãƒ¼ã‚¸ãƒ§ãƒ³è¿”å´
        return self.default_version
        
    def handle_version_compatibility(self, version: str, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§å‡¦ç†"""
        
        # ãƒãƒ¼ã‚¸ãƒ§ãƒ³å›ºæœ‰ã®å¤‰æ›å‡¦ç†
        if version == 'v1' and endpoint == 'behavior_analysis':
            return self._convert_v1_to_v2_behavior_analysis(data)
        elif version == 'v1' and endpoint == 'detection_results':
            return self._convert_v1_to_v2_detection_results(data)
            
        return data
        
    def _convert_v1_to_v2_behavior_analysis(self, v1_data: Dict[str, Any]) -> Dict[str, Any]:
        """v1ã‹ã‚‰v2ã¸ã®è¡Œå‹•åˆ†æãƒ‡ãƒ¼ã‚¿å¤‰æ›"""
        v2_data = v1_data.copy()
        
        # v2ã§è¿½åŠ ã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤è¨­å®š
        if 'emotional_state' not in v2_data:
            v2_data['emotional_state'] = {
                'valence': 0.5,
                'arousal': 0.5,
                'confidence': 0.0
            }
            
        # v1ã§å»ƒæ­¢ã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®é™¤å»
        if 'legacy_score' in v2_data:
            del v2_data['legacy_score']
            
        return v2_data

# äº’æ›æ€§ãƒã‚§ãƒƒã‚¯è‡ªå‹•åŒ–
class CompatibilityTester:
    """äº’æ›æ€§ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–"""
    
    def __init__(self):
        self.test_scenarios = self._load_compatibility_scenarios()
        
    def run_compatibility_tests(self, feature_branch: str) -> Dict[str, Any]:
        """äº’æ›æ€§ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        results = {
            'api_compatibility': self._test_api_compatibility(),
            'data_compatibility': self._test_data_compatibility(),
            'plugin_compatibility': self._test_plugin_compatibility(),
            'performance_impact': self._test_performance_impact()
        }
        
        return results
        
    def _test_api_compatibility(self) -> Dict[str, Any]:
        """APIäº’æ›æ€§ãƒ†ã‚¹ãƒˆ"""
        test_results = {}
        
        for scenario in self.test_scenarios['api_tests']:
            try:
                # æ—¢å­˜APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ
                response = self._execute_api_test(scenario)
                test_results[scenario['name']] = {
                    'status': 'passed',
                    'response_time': response.elapsed.total_seconds(),
                    'status_code': response.status_code
                }
            except Exception as e:
                test_results[scenario['name']] = {
                    'status': 'failed',
                    'error': str(e)
                }
                
        return test_results
```

== ğŸ“‹ è¨­è¨ˆã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³

=== ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åŸå‰‡

**æ‹¡å¼µè¨­è¨ˆã®åŸºæœ¬åŸå‰‡**
[cols="2,3,2", options="header"]
|===
|åŸå‰‡ |èª¬æ˜ |å®Ÿè£…æ–¹æ³•
|**å˜ä¸€è²¬ä»»** |å„æ‹¡å¼µã¯ä¸€ã¤ã®æ˜ç¢ºãªè²¬ä»»ã‚’æŒã¤ |æ©Ÿèƒ½ã”ã¨ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åˆ†é›¢
|**ä¾å­˜æ€§é€†è»¢** |ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã¯æ‹¡å¼µã«ä¾å­˜ã—ãªã„ |ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹çµŒç”±ã®ç–çµåˆ
|**é–‹æ”¾é–‰é–** |æ‹¡å¼µã«ã¯é–‹æ”¾ã€ä¿®æ­£ã«ã¯é–‰é– |ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ´»ç”¨
|**ãƒªã‚¹ã‚³ãƒ•ç½®æ›** |æ‹¡å¼µã¯åŸºåº•ã‚¯ãƒ©ã‚¹ã¨ç½®æ›å¯èƒ½ |æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ã®ç¶™æ‰¿
|**ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åˆ†é›¢** |å¿…è¦ãªæ©Ÿèƒ½ã®ã¿ã‚’å…¬é–‹ |æœ€å°é™ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
|===

**ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„**
```python
# æ‹¡å¼µé–‹ç™ºã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¦ç´„ä¾‹

# 1. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¯ãƒ©ã‚¹å‘½åè¦ç´„
class CustomDetectionExtension(DetectionExtension):
    """
    å‘½åè¦ç´„:
    - ã‚¯ãƒ©ã‚¹å: {Purpose}{Type}Extension
    - ãƒ•ã‚¡ã‚¤ãƒ«å: {plugin_name}_extension.py
    - ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å: extensions.{category}.{plugin_name}
    """
    
    # 2. å¿…é ˆãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…
    def get_name(self) -> str:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å (è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿)"""
        return "custom_detection"
        
    def get_version(self) -> str:
        """ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°"""
        return "1.2.3"
        
    def get_description(self) -> str:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®èª¬æ˜"""
        return "Custom object detection using proprietary AI model"
        
    def get_author(self) -> str:
        """ä½œæˆè€…æƒ…å ±"""
        return "Development Team <dev@company.com>"
        
    def get_dependencies(self) -> List[str]:
        """ä¾å­˜é–¢ä¿‚"""
        return ["numpy>=1.21.0", "opencv-python>=4.5.0"]
        
    # 3. è¨­å®šãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """è¨­å®šå€¤æ¤œè¨¼"""
        required_keys = ['model_path', 'confidence_threshold']
        return all(key in config for key in required_keys)
        
    # 4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    def initialize(self, config: Dict[str, Any]) -> bool:
        try:
            if not self.validate_config(config):
                raise ValueError("Invalid configuration")
                
            self._load_model(config['model_path'])
            self.confidence_threshold = config['confidence_threshold']
            
            logger.info(f"Plugin {self.get_name()} v{self.get_version()} initialized")
            return True
            
        except Exception as e:
            logger.error(f"Plugin initialization failed: {e}")
            return False
            
    # 5. ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†
    def cleanup(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾"""
        if hasattr(self, 'model') and self.model:
            del self.model
            
        if hasattr(self, 'temp_files'):
            for temp_file in self.temp_files:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
                    
        logger.info(f"Plugin {self.get_name()} cleanup completed")

# 6. ãƒ†ã‚¹ãƒˆå®Ÿè£…å¿…é ˆ
class TestCustomDetectionExtension(unittest.TestCase):
    """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹"""
    
    def setUp(self):
        self.plugin = CustomDetectionExtension()
        self.test_config = {
            'model_path': 'test_models/test_model.onnx',
            'confidence_threshold': 0.7
        }
        
    def test_initialization(self):
        """åˆæœŸåŒ–ãƒ†ã‚¹ãƒˆ"""
        result = self.plugin.initialize(self.test_config)
        self.assertTrue(result)
        
    def test_detection(self):
        """æ¤œå‡ºå‡¦ç†ãƒ†ã‚¹ãƒˆ"""
        # ãƒ†ã‚¹ãƒˆç”»åƒãƒ‡ãƒ¼ã‚¿
        test_image = self._load_test_image()
        
        # æ¤œå‡ºå®Ÿè¡Œ
        detections = self.plugin.detect(test_image, {})
        
        # çµæœæ¤œè¨¼
        self.assertIsInstance(detections, list)
        if detections:
            self.assertIn('confidence', detections[0])
            self.assertIn('bbox', detections[0])
```

== ğŸ¯ ã¾ã¨ã‚

KanshiChanã®æ‹¡å¼µãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚·ã‚¹ãƒ†ãƒ ã¯ä»¥ä¸‹ã®åŒ…æ‹¬çš„ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ï¼š

=== ä¸»è¦æ‹¡å¼µæ©Ÿèƒ½

* âœ… **ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**: å‹•çš„ãªæ©Ÿèƒ½æ‹¡å¼µã‚·ã‚¹ãƒ†ãƒ 
* âœ… **æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ**: æ¤œå‡ºãƒ»åˆ†æãƒ»é€šçŸ¥ãƒ»APIå‡¦ç†ã®æ‹¡å¼µ
* âœ… **äº’æ›æ€§ä¿æŒ**: APIãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã¨å¾Œæ–¹äº’æ›æ€§
* âœ… **é–‹ç™ºã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³**: æ¨™æº–åŒ–ã•ã‚ŒãŸæ‹¡å¼µé–‹ç™ºãƒ—ãƒ­ã‚»ã‚¹

=== æ‹¡å¼µé–‹ç™ºã®æµã‚Œ

[cols="3,2,2", options="header"]
|===
|é–‹ç™ºæ®µéš |ä¸»è¦ä½œæ¥­ |æˆæœç‰©
|**è¨­è¨ˆ** |è¦ä»¶å®šç¾©ãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ |è¨­è¨ˆæ›¸ãƒ»ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ä»•æ§˜
|**å®Ÿè£…** |ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆå®Ÿè£… |æ‹¡å¼µã‚³ãƒ¼ãƒ‰ãƒ»ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
|**çµ±åˆ** |äº’æ›æ€§ãƒã‚§ãƒƒã‚¯ãƒ»æ€§èƒ½è©•ä¾¡ |çµ±åˆãƒ†ã‚¹ãƒˆçµæœãƒ»æ€§èƒ½ãƒ¬ãƒãƒ¼ãƒˆ
|**é‹ç”¨** |ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»ç›£è¦–ãƒ»ä¿å®ˆ |é‹ç”¨æ‰‹é †æ›¸ãƒ»ç›£è¦–è¨­å®š
|===

=== å“è³ªä¿è¨¼

1. **æ¨™æº–åŒ–**: çµ±ä¸€ã•ã‚ŒãŸãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
2. **è‡ªå‹•åŒ–**: äº’æ›æ€§ãƒã‚§ãƒƒã‚¯ã¨ãƒ†ã‚¹ãƒˆã®è‡ªå‹•å®Ÿè¡Œ
3. **ç›£è¦–**: æ‹¡å¼µæ©Ÿèƒ½ã®æ€§èƒ½ãƒ»å®‰å®šæ€§ç›£è¦–
4. **æ–‡æ›¸åŒ–**: åŒ…æ‹¬çš„ãªé–‹ç™ºã‚¬ã‚¤ãƒ‰ã¨APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

---

**ğŸ“ Contact**: team@kanshichan.dev +
**ğŸ”— Repository**: https://github.com/kanshichan/backend +
**ğŸ“… Last Updated**: {docdate} +
**ğŸ“ Document Version**: {revnumber}