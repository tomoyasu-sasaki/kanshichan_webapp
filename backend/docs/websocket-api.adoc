= ğŸŒ ç›£è¦–ã¡ã‚ƒã‚“(KanshiChan) WebSocket APIä»•æ§˜æ›¸
:toc: left
:toc-title: ç›®æ¬¡
:toclevels: 4
:numbered:
:source-highlighter: highlight.js
:icons: font
:doctype: book
:version: 2.0.0
:author: KanshiChan Development Team
:email: team@kanshichan.dev
:revnumber: 2.0
:revdate: {docdate}
:experimental:

== ğŸ“– æ¦‚è¦

ç›£è¦–ã¡ã‚ƒã‚“ï¼ˆKanshiChanï¼‰ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡ã‚’æ‹…ã†WebSocket APIä»•æ§˜æ›¸ã§ã™ã€‚
ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰é–“ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿äº¤æ›ã€éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã€çŠ¶æ…‹é€šçŸ¥æ©Ÿèƒ½ã«ã¤ã„ã¦è©³ç´°ãªä»•æ§˜ã‚’æä¾›ã—ã¾ã™ã€‚

[NOTE]
====
ğŸ“‹ **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæƒ…å ±**

* **å¯¾è±¡èª­è€…**: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰é–‹ç™ºè€…ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ©Ÿèƒ½é–‹ç™ºè€…ã€ã‚·ã‚¹ãƒ†ãƒ çµ±åˆæ‹…å½“è€…
* **æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯**: Socket.IO (Flask-SocketIO) / JavaScript/TypeScript Client
* **é€šä¿¡æ–¹å¼**: WebSocket over HTTP/HTTPSã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæ–¹å‘é€šä¿¡
* **ä¸»è¦æ©Ÿèƒ½**: ç›£è¦–çŠ¶æ…‹é…ä¿¡ã€éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã€ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥ã€è¡Œå‹•åˆ†æçµæœé…ä¿¡
* **ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: v2.0.0 (éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ»TTSçµ±åˆç‰ˆ)
* **æœ€çµ‚æ›´æ–°**: {docdate}

**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: <<rest-api-reference>>, <<communication-system>>, <<development-guide>>
====

== ğŸ¯ WebSocket APIæ¦‚è¦

=== ğŸ’¡ è¨­è¨ˆæ€æƒ³

==== ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡ã®åŸå‰‡
* **ä½é…å»¶**: ç›£è¦–ãƒ‡ãƒ¼ã‚¿ã®å³åº§ãªé…ä¿¡ï¼ˆ<100msï¼‰
* **ä¿¡é ¼æ€§**: æ¥ç¶šæ–­çµ¶æ™‚ã®è‡ªå‹•å†æ¥ç¶šæ©Ÿèƒ½
* **åŠ¹ç‡æ€§**: å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã®ã¿ã®å·®åˆ†é…ä¿¡
* **æ‹¡å¼µæ€§**: æ–°æ©Ÿèƒ½è¿½åŠ ã«å¯¾å¿œã—ãŸæŸ”è»Ÿãªè¨­è¨ˆ
* **å›½éš›åŒ–**: å¤šè¨€èªå¯¾å¿œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

==== ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦
[mermaid]
....
graph TB
    subgraph "ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´"
        WEB[Webãƒ–ãƒ©ã‚¦ã‚¶]
        WS_CLIENT[WebSocket Client<br/>Socket.IO Client]
        AUDIO_MGR[AudioManager<br/>éŸ³å£°å†ç”Ÿç®¡ç†]
        UI[UI Components<br/>MonitorView, etc.]
    end
    
    subgraph "ã‚µãƒ¼ãƒãƒ¼å´"
        WS_SERVER[WebSocket Server<br/>Flask-SocketIO]
        STATUS_BC[StatusBroadcaster<br/>çŠ¶æ…‹é…ä¿¡]
        AUDIO_STREAM[AudioStreaming<br/>éŸ³å£°é…ä¿¡]
        TTS_SRV[TTS Service<br/>éŸ³å£°åˆæˆ]
    end
    
    subgraph "ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚·ã‚¹ãƒ†ãƒ "
        DETECTOR[Object Detector<br/>ç‰©ä½“æ¤œå‡º]
        STATE_MGR[State Manager<br/>çŠ¶æ…‹ç®¡ç†]
        BEHAVIOR[Behavior Analysis<br/>è¡Œå‹•åˆ†æ]
        SCHEDULE[Schedule Checker<br/>ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†]
    end
    
    WEB --> WS_CLIENT
    WS_CLIENT <--> WS_SERVER
    WS_CLIENT --> AUDIO_MGR
    AUDIO_MGR --> UI
    WS_CLIENT --> UI
    
    WS_SERVER --> STATUS_BC
    WS_SERVER --> AUDIO_STREAM
    STATUS_BC --> DETECTOR
    STATUS_BC --> STATE_MGR
    STATUS_BC --> BEHAVIOR
    AUDIO_STREAM --> TTS_SRV
    WS_SERVER --> SCHEDULE
    
    classDef client fill:#e3f2fd
    classDef server fill:#f3e5f5
    classDef backend fill:#e8f5e8
    
    class WEB,WS_CLIENT,AUDIO_MGR,UI client
    class WS_SERVER,STATUS_BC,AUDIO_STREAM,TTS_SRV server
    class DETECTOR,STATE_MGR,BEHAVIOR,SCHEDULE backend
....

=== ğŸ”Œ æ¥ç¶šä»•æ§˜

==== åŸºæœ¬æ¥ç¶šæƒ…å ±
[cols="2,3", options="header"]
|===
|é …ç›® |è©³ç´°
|**ãƒ—ãƒ­ãƒˆã‚³ãƒ«** |WebSocket (Socket.IO v4+)
|**ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ** |`ws://localhost:8000/socket.io/`
|**åå‰ç©ºé–“** |ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ (`/`)
|**èªè¨¼** |ç¾åœ¨ã¯èªè¨¼ãªã—ï¼ˆv3.0ã§å®Ÿè£…äºˆå®šï¼‰
|**CORS** |`*` (é–‹ç™ºç’°å¢ƒ), æœ¬ç•ªç’°å¢ƒã§ã¯åˆ¶é™å¿…è¦
|**ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆ** |30ç§’é–“éš” (Socket.IOè‡ªå‹•ç®¡ç†)
|===

==== æ¥ç¶šãƒ•ãƒ­ãƒ¼
[mermaid]
....
sequenceDiagram
    participant C as Client
    participant S as Server
    
    Note over C: WebSocketæ¥ç¶šé–‹å§‹
    C->>S: connect()
    S->>C: connect event
    Note over S: client_idã‚’connected_clientsã«è¿½åŠ 
    S-->>C: åˆæœŸçŠ¶æ…‹ãƒ‡ãƒ¼ã‚¿ (status_update)
    
    Note over C,S: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡é–‹å§‹
    
    loop ç›£è¦–ãƒ‡ãƒ¼ã‚¿é…ä¿¡
        S->>C: status_update (æ¤œå‡ºçŠ¶æ…‹)
        S->>C: behavior_data (è¡Œå‹•ãƒ‡ãƒ¼ã‚¿)
        S->>C: analysis_results (åˆ†æçµæœ)
    end
    
    loop éŸ³å£°é…ä¿¡ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
        S->>C: audio_notification (é…ä¿¡æº–å‚™)
        S->>C: audio_stream (éŸ³å£°ãƒ‡ãƒ¼ã‚¿)
        C->>S: audio_playback_status (å†ç”ŸçŠ¶æ…‹)
    end
    
    Note over C: æ¥ç¶šçµ‚äº†
    C->>S: disconnect()
    Note over S: client_idã‚’connected_clientsã‹ã‚‰å‰Šé™¤
....

== ğŸ“¡ WebSocketã‚¤ãƒ™ãƒ³ãƒˆä»•æ§˜

=== ğŸ“¤ ã‚µãƒ¼ãƒãƒ¼é€ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆServer â†’ Clientï¼‰

==== 1. `status_update` - ç›£è¦–çŠ¶æ…‹æ›´æ–°

**æ¦‚è¦**: ãƒ¡ã‚¤ãƒ³ã®ç›£è¦–çŠ¶æ…‹ãƒ‡ãƒ¼ã‚¿ã‚’é…ä¿¡ã—ã¾ã™ã€‚

**é€ä¿¡é »åº¦**: ç´„30FPSï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†ã”ã¨ï¼‰

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "personDetected": boolean,
  "smartphoneDetected": boolean, 
  "absenceTime": number,
  "smartphoneUseTime": number,
  "absenceAlert": boolean,
  "smartphoneAlert": boolean,
  "timestamp": "2024-01-20T10:30:45.123Z",
  "frameId": number,
  "detectionConfidence": {
    "person": number,
    "smartphone": number
  }
}
```

**å®Ÿè£…ä¾‹**:
```python
# ã‚µãƒ¼ãƒãƒ¼å´é€ä¿¡
def broadcast_status(status):
    socketio.emit('status_update', status)
```

```typescript
// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´å—ä¿¡
websocketManager.onStatusUpdate((status: DetectionStatus) => {
  console.log('Status updated:', status);
  setMonitoringStatus(status);
});
```

==== 2. `behavior_data` - è¡Œå‹•ãƒ‡ãƒ¼ã‚¿é…ä¿¡

**æ¦‚è¦**: è©³ç´°ãªè¡Œå‹•åˆ†æãƒ‡ãƒ¼ã‚¿ã‚’é…ä¿¡ã—ã¾ã™ã€‚

**é€ä¿¡æ¡ä»¶**: è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¤‰åŒ–æ™‚ã€ã¾ãŸã¯åˆ†æå®Œäº†æ™‚

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "userId": string,
  "timestamp": "2024-01-20T10:30:45.123Z",
  "behaviors": [
    {
      "type": "posture_change",
      "confidence": 0.95,
      "duration": 300,
      "metadata": {
        "fromPosture": "sitting",
        "toPosture": "standing"
      }
    }
  ],
  "sessionData": {
    "sessionId": string,
    "totalDuration": number,
    "activityCount": number
  }
}
```

==== 3. `analysis_results` - åˆ†æçµæœé…ä¿¡

**æ¦‚è¦**: è¡Œå‹•åˆ†æã®é›†è¨ˆçµæœã‚’é…ä¿¡ã—ã¾ã™ã€‚

**é€ä¿¡æ¡ä»¶**: åˆ†æå‡¦ç†å®Œäº†æ™‚ï¼ˆé€šå¸¸5-10åˆ†é–“éš”ï¼‰

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "analysisId": string,
  "timestamp": "2024-01-20T10:30:45.123Z",
  "timeRange": {
    "start": "2024-01-20T10:20:00.000Z",
    "end": "2024-01-20T10:30:00.000Z"
  },
  "summary": {
    "totalWorkTime": number,
    "breakTime": number,
    "smartphoneUsage": number,
    "productivityScore": number
  },
  "patterns": [
    {
      "pattern": "focus_period",
      "duration": 1800,
      "quality": "high"
    }
  ]
}
```

==== 4. `audio_stream` - éŸ³å£°ãƒ‡ãƒ¼ã‚¿é…ä¿¡

**æ¦‚è¦**: TTSç”ŸæˆéŸ³å£°ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é…ä¿¡ã—ã¾ã™ã€‚

**é€ä¿¡æ¡ä»¶**: TTSã‚µãƒ¼ãƒ“ã‚¹ã§éŸ³å£°ç”Ÿæˆå®Œäº†æ™‚

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "audio_data": string,  // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ¸ˆã¿
  "metadata": {
    "audio_id": string,
    "file_id": string,
    "text_content": string,
    "emotion": "neutral",
    "language": "ja",
    "synthesis_timestamp": "2024-01-20T10:30:45.123Z",
    "file_size": number,
    "streaming_mode": boolean,
    "broadcast_mode": boolean
  },
  "timestamp": "2024-01-20T10:30:45.123Z",
  "format": "audio/wav",
  "encoding": "base64"
}
```

**éŸ³å£°å†ç”Ÿãƒ•ãƒ­ãƒ¼**:
[mermaid]
....
sequenceDiagram
    participant TTS as TTS Service
    participant WS as WebSocket Server
    participant C as Client
    participant AM as AudioManager
    
    Note over TTS: éŸ³å£°åˆæˆå‡¦ç†
    TTS->>WS: éŸ³å£°ãƒ‡ãƒ¼ã‚¿æº–å‚™å®Œäº†
    WS->>C: audio_notification (audio_ready)
    WS->>C: audio_stream (éŸ³å£°ãƒ‡ãƒ¼ã‚¿)
    
    C->>AM: éŸ³å£°ãƒ‡ãƒ¼ã‚¿å—ä¿¡
    AM->>AM: Base64ãƒ‡ã‚³ãƒ¼ãƒ‰
    AM->>AM: AudioBufferç”Ÿæˆ
    AM->>AM: éŸ³å£°å†ç”Ÿé–‹å§‹
    C->>WS: audio_playback_status (playing)
    
    Note over AM: éŸ³å£°å†ç”Ÿä¸­...
    
    AM->>AM: å†ç”Ÿå®Œäº†
    C->>WS: audio_playback_status (finished)
....

==== 5. `audio_notification` - éŸ³å£°é–¢é€£é€šçŸ¥

**æ¦‚è¦**: éŸ³å£°å‡¦ç†ã®çŠ¶æ…‹å¤‰åŒ–ã‚’é€šçŸ¥ã—ã¾ã™ã€‚

**é€šçŸ¥ã‚¿ã‚¤ãƒ—**: `tts_started`, `tts_completed`, `tts_error`, `audio_ready`, `broadcast_completed`, `broadcast_error`

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "type": "audio_ready",
  "message": "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒé…ä¿¡æº–å‚™å®Œäº†: ä»Šæ—¥ã®ä½œæ¥­çŠ¶æ³ã‚’ãŠçŸ¥ã‚‰ã›ã—ã¾ã™...",
  "audio_id": "audio_20240120_103045_123",
  "timestamp": "2024-01-20T10:30:45.123Z"
}
```

==== 6. `audio_status_update` - éŸ³å£°å†ç”ŸçŠ¶æ…‹å…±æœ‰

**æ¦‚è¦**: ä»–ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®éŸ³å£°å†ç”ŸçŠ¶æ…‹ã‚’å…±æœ‰ã—ã¾ã™ã€‚

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "client_id": "socket_client_abc123",
  "audio_id": "audio_20240120_103045_123", 
  "status": "playing"  // "playing", "finished", "error"
}
```

==== 7. `schedule_alert` - ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¢ãƒ©ãƒ¼ãƒˆ

**æ¦‚è¦**: ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†æ©Ÿèƒ½ã‹ã‚‰ã®ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥ã§ã™ã€‚

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "type": "schedule_alert",
  "content": "10åˆ†å¾Œã«ä¼šè­°ãŒäºˆå®šã•ã‚Œã¦ã„ã¾ã™",
  "time": "2024-01-20T10:40:00.000Z",
  "severity": "info",  // "info", "warning", "critical"
  "scheduleId": "schedule_abc123"
}
```

==== 8. `broadcast_notification` - ä¸€èˆ¬é€šçŸ¥é…ä¿¡

**æ¦‚è¦**: ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã¸ã®ä¸€èˆ¬çš„ãªé€šçŸ¥ã‚’é…ä¿¡ã—ã¾ã™ã€‚

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "message": "ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã‚’é–‹å§‹ã—ã¾ã™",
  "type": "system",  // "system", "user", "alert"
  "timestamp": "2024-01-20T10:30:45.123Z",
  "priority": "high"  // "low", "normal", "high", "critical"
}
```

=== ğŸ“¥ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆClient â†’ Serverï¼‰

==== 1. `connect` - æ¥ç¶šç¢ºç«‹

**æ¦‚è¦**: WebSocketæ¥ç¶šã®ç¢ºç«‹æ™‚ã«è‡ªå‹•é€ä¿¡ã•ã‚Œã¾ã™ã€‚

**å‡¦ç†å†…å®¹**:
- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆIDã®ç”Ÿæˆã¨connected_clientsãƒªã‚¹ãƒˆã¸ã®è¿½åŠ 
- åˆæœŸçŠ¶æ…‹ãƒ‡ãƒ¼ã‚¿ã®é€ä¿¡
- æ¥ç¶šãƒ­ã‚°ã®è¨˜éŒ²

**å®Ÿè£…ä¾‹**:
```python
@socketio.on('connect')
def handle_connect():
    client_id = request.sid
    connected_clients.append(client_id)
    logger.info(f'Client connected: {client_id}')
```

==== 2. `disconnect` - æ¥ç¶šåˆ‡æ–­

**æ¦‚è¦**: WebSocketæ¥ç¶šã®åˆ‡æ–­æ™‚ã«è‡ªå‹•é€ä¿¡ã•ã‚Œã¾ã™ã€‚

**å‡¦ç†å†…å®¹**:
- connected_clientsãƒªã‚¹ãƒˆã‹ã‚‰ã®å‰Šé™¤
- ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
- åˆ‡æ–­ãƒ­ã‚°ã®è¨˜éŒ²

==== 3. `audio_playback_status` - éŸ³å£°å†ç”ŸçŠ¶æ…‹é€šçŸ¥

**æ¦‚è¦**: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã®éŸ³å£°å†ç”ŸçŠ¶æ…‹ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€šçŸ¥ã—ã¾ã™ã€‚

**é€ä¿¡ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: éŸ³å£°å†ç”Ÿé–‹å§‹æ™‚ã€å®Œäº†æ™‚ã€ã‚¨ãƒ©ãƒ¼æ™‚

**ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰å½¢å¼**:
```json
{
  "status": "playing",  // "playing", "finished", "error"
  "audio_id": "audio_20240120_103045_123",
  "client_info": {
    "browser": "Chrome",
    "version": "120.0.0.0",
    "audio_support": "webaudio"
  }
}
```

**å®Ÿè£…ä¾‹**:
```typescript
// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´é€ä¿¡
websocketManager.notifyAudioPlaybackStatus(audioId, 'playing');

// ã‚µãƒ¼ãƒãƒ¼å´å—ä¿¡
@socketio.on('audio_playback_status')
def handle_audio_status(data):
    client_id = request.sid
    status = data.get('status')
    audio_id = data.get('audio_id')
    logger.info(f"Audio playback status from {client_id}: {status} for audio {audio_id}")
```

== ğŸ”„ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè©³ç´°

=== ğŸ“‹ å…±é€šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰

å…¨ã¦ã®WebSocketãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å«ã¾ã‚Œã‚‹å…±é€šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼š

[cols="2,1,3", options="header"]
|===
|ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å |å‹ |èª¬æ˜
|**timestamp** |string |ISO 8601å½¢å¼ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
|**messageId** |string |ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¸€æ„è­˜åˆ¥å­ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
|**version** |string |ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
|===

=== ğŸ—ï¸ ãƒ‡ãƒ¼ã‚¿å‹å®šç¾©

==== TypeScriptå‹å®šç¾©
```typescript
// åŸºæœ¬æ¤œå‡ºçŠ¶æ…‹
interface DetectionStatus {
  personDetected: boolean;
  smartphoneDetected: boolean;
  absenceTime: number;
  smartphoneUseTime: number;
  absenceAlert?: boolean;
  smartphoneAlert?: boolean;
  timestamp?: string;
  frameId?: number;
  detectionConfidence?: {
    person: number;
    smartphone: number;
  };
}

// éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿
interface AudioStreamData {
  audio_data: string;  // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
  metadata: {
    audio_id: string;
    file_id?: string;
    text_content: string;
    emotion: string;
    language: string;
    synthesis_timestamp: string;
    file_size: number;
    streaming_mode?: boolean;
    broadcast_mode?: boolean;
  };
  timestamp: string;
  format: string;
  encoding: string;
}

// è¡Œå‹•ãƒ‡ãƒ¼ã‚¿
interface BehaviorData {
  userId: string;
  timestamp: string;
  behaviors: BehaviorEvent[];
  sessionData: {
    sessionId: string;
    totalDuration: number;
    activityCount: number;
  };
}

interface BehaviorEvent {
  type: string;
  confidence: number;
  duration: number;
  metadata: Record<string, any>;
}
```

=== ğŸ”§ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

==== ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼
```json
{
  "error": true,
  "errorCode": "WEBSOCKET_ERROR_001",
  "message": "Audio streaming failed",
  "details": {
    "audio_id": "audio_20240120_103045_123",
    "client_id": "socket_client_abc123",
    "error_type": "ENCODING_ERROR"
  },
  "timestamp": "2024-01-20T10:30:45.123Z"
}
```

==== ä¸€èˆ¬çš„ãªã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰
[cols="2,3,2", options="header"]
|===
|ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ |èª¬æ˜ |å¯¾å‡¦æ³•
|**CONNECTION_FAILED** |WebSocketæ¥ç¶šã«å¤±æ•— |ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ³ç¢ºèªã€å†æ¥ç¶š
|**AUDIO_DECODE_ERROR** |éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•— |éŸ³å£°å½¢å¼ç¢ºèªã€ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œç¢ºèª
|**BUFFER_OVERFLOW** |ãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ•ã‚¡ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ |æ¥ç¶šå“è³ªç¢ºèªã€ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºèª¿æ•´
|**INVALID_MESSAGE** |ç„¡åŠ¹ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼ |ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å½¢å¼ç¢ºèªã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¢ºèª
|**AUTH_REQUIRED** |èªè¨¼ãŒå¿…è¦ï¼ˆå°†æ¥å®Ÿè£…ï¼‰ |èªè¨¼æƒ…å ±ç¢ºèª
|===

== ğŸš€ æ¥ç¶šãƒ»åˆ‡æ–­å‡¦ç†

=== ğŸ”Œ æ¥ç¶šç¢ºç«‹æ‰‹é †

==== 1. åŸºæœ¬æ¥ç¶š
```typescript
import { io, Socket } from 'socket.io-client';

const socket: Socket = io('ws://localhost:8000', {
  transports: ['websocket'],
  timeout: 5000,
  autoConnect: true
});
```

==== 2. æ¥ç¶šç¢ºèªã¨ãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
```typescript
socket.on('connect', () => {
  console.log('Connected to KanshiChan WebSocket');
  console.log('Socket ID:', socket.id);
});

socket.on('disconnect', (reason: string) => {
  console.log('Disconnected:', reason);
  if (reason === 'io server disconnect') {
    // ã‚µãƒ¼ãƒãƒ¼å´ã‹ã‚‰ã®åˆ‡æ–­ã®å ´åˆã€æ‰‹å‹•å†æ¥ç¶š
    socket.connect();
  }
});
```

==== 3. è‡ªå‹•å†æ¥ç¶šè¨­å®š
```typescript
socket.on('connect_error', (error: Error) => {
  console.error('Connection error:', error);
  
  // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§å†æ¥ç¶š
  setTimeout(() => {
    socket.connect();
  }, Math.min(1000 * Math.pow(2, reconnectAttempts), 30000));
});
```

=== ğŸ”„ å†æ¥ç¶šæˆ¦ç•¥

[mermaid]
....
stateDiagram-v2
    [*] --> Disconnected
    Disconnected --> Connecting : connect()
    Connecting --> Connected : success
    Connecting --> Error : failure
    Connected --> Disconnected : network_error
    Connected --> Disconnected : server_disconnect
    Error --> Waiting : backoff
    Waiting --> Connecting : retry
    
    note right of Error
        æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•:
        1s â†’ 2s â†’ 4s â†’ 8s â†’ 16s â†’ 30s (max)
    end note
....

==== å†æ¥ç¶šå®Ÿè£…ä¾‹
```typescript
class WebSocketManager {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private baseDelay = 1000;
  
  private handleReconnection() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached');
      return;
    }
    
    const delay = Math.min(
      this.baseDelay * Math.pow(2, this.reconnectAttempts),
      30000
    );
    
    setTimeout(() => {
      this.reconnectAttempts++;
      this.socket?.connect();
    }, delay);
  }
}
```

== âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®äº‹é …

=== ğŸ“Š ãƒ‡ãƒ¼ã‚¿é…ä¿¡æœ€é©åŒ–

==== ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆèª¿æ•´
```python
# ã‚µãƒ¼ãƒãƒ¼å´ã§ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡
class StatusBroadcaster:
    def __init__(self):
        self.last_broadcast_time = 0
        self.min_broadcast_interval = 1/30  # 30FPSåˆ¶é™
    
    def broadcast_status(self):
        current_time = time.time()
        if current_time - self.last_broadcast_time >= self.min_broadcast_interval:
            # ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆå®Ÿè¡Œ
            broadcast_status(status)
            self.last_broadcast_time = current_time
```

==== ãƒ‡ãƒ¼ã‚¿åœ§ç¸®ã¨å·®åˆ†é…ä¿¡
```python
# å·®åˆ†ãƒ‡ãƒ¼ã‚¿ã®ã¿é…ä¿¡
def create_delta_status(current_status, previous_status):
    delta = {}
    for key, value in current_status.items():
        if key not in previous_status or previous_status[key] != value:
            delta[key] = value
    return delta if delta else None
```

=== ğŸµ éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°æœ€é©åŒ–

==== ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°æˆ¦ç•¥
```typescript
class AudioManager {
  private audioQueue: AudioBuffer[] = [];
  private maxQueueSize = 5;
  
  async queueAudioBuffer(audioBuffer: AudioBuffer) {
    if (this.audioQueue.length >= this.maxQueueSize) {
      this.audioQueue.shift(); // å¤ã„ãƒãƒƒãƒ•ã‚¡ã‚’å‰Šé™¤
    }
    this.audioQueue.push(audioBuffer);
  }
}
```

==== å“è³ªèª¿æ•´
[cols="2,2,2,2", options="header"]
|===
|ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ³ |éŸ³å£°å“è³ª |ãƒ“ãƒƒãƒˆãƒ¬ãƒ¼ãƒˆ |ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚º
|**è‰¯å¥½** |é«˜å“è³ª |44.1kHz/16bit |512KB
|**æ™®é€š** |æ¨™æº–å“è³ª |22.05kHz/16bit |256KB
|**ä¸å®‰å®š** |ä½å“è³ª |11.025kHz/8bit |128KB
|===

=== ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

==== ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
```typescript
interface WebSocketMetrics {
  messagesSent: number;
  messagesReceived: number;
  averageLatency: number;
  connectionUptime: number;
  audioBufferUnderruns: number;
  errorCount: number;
}

class MetricsCollector {
  private metrics: WebSocketMetrics = {
    messagesSent: 0,
    messagesReceived: 0,
    averageLatency: 0,
    connectionUptime: 0,
    audioBufferUnderruns: 0,
    errorCount: 0
  };
  
  recordMessage(type: 'sent' | 'received') {
    if (type === 'sent') this.metrics.messagesSent++;
    else this.metrics.messagesReceived++;
  }
}
```

== ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

=== ğŸ›¡ï¸ ç¾åœ¨ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

==== CORSè¨­å®š
```python
# é–‹ç™ºç’°å¢ƒ
socketio = SocketIO(cors_allowed_origins="*")

# æœ¬ç•ªç’°å¢ƒï¼ˆæ¨å¥¨ï¼‰
socketio = SocketIO(cors_allowed_origins=[
    "https://kanshichan.yourdomain.com",
    "https://app.kanshichan.yourdomain.com"
])
```

==== ãƒ‡ãƒ¼ã‚¿ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
```python
def sanitize_websocket_data(data):
    """WebSocketãƒ‡ãƒ¼ã‚¿ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³"""
    if isinstance(data, dict):
        sanitized = {}
        for key, value in data.items():
            # MediaPipeã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®‰å…¨ãªå½¢å¼ã«å¤‰æ›
            if hasattr(value, 'landmark'):
                sanitized[key] = serialize_landmarks(value)
            else:
                sanitized[key] = value
        return sanitized
    return data
```

=== ğŸ”’ å°†æ¥ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®Ÿè£…è¨ˆç”»

==== èªè¨¼ãƒ»èªå¯ï¼ˆv3.0äºˆå®šï¼‰
```typescript
// JWTèªè¨¼ã®å®Ÿè£…äºˆå®š
const socket = io('wss://kanshichan.yourdomain.com', {
  auth: {
    token: 'jwt_token_here'
  }
});

// ã‚µãƒ¼ãƒãƒ¼å´èªè¨¼
@socketio.on('connect')
def handle_connect(auth):
    token = auth.get('token')
    if not verify_jwt_token(token):
        disconnect()
```

==== ãƒ¬ãƒ¼ãƒˆåˆ¶é™
```python
# æ¥ç¶šã‚ãŸã‚Šã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ¬ãƒ¼ãƒˆåˆ¶é™
class RateLimiter:
    def __init__(self, max_messages_per_minute=100):
        self.limits = {}
        self.max_messages = max_messages_per_minute
    
    def check_rate(self, client_id):
        current_time = time.time()
        if client_id not in self.limits:
            self.limits[client_id] = []
        
        # 1åˆ†ä»¥å†…ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        recent_messages = [
            t for t in self.limits[client_id] 
            if current_time - t < 60
        ]
        
        if len(recent_messages) >= self.max_messages:
            return False
        
        self.limits[client_id] = recent_messages + [current_time]
        return True
```

== ğŸ’» ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè£…ä¾‹

=== ğŸš€ åŸºæœ¬å®Ÿè£…ï¼ˆTypeScriptï¼‰

==== WebSocketãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹
```typescript
import { io, Socket } from 'socket.io-client';

class WebSocketManager {
  private socket: Socket | null = null;
  private statusUpdateCallbacks: Array<(status: DetectionStatus) => void> = [];
  private audioManager: AudioManager;
  
  constructor() {
    this.audioManager = new AudioManager();
  }
  
  public initialize() {
    this.socket = io('ws://localhost:8000', {
      transports: ['websocket'],
      timeout: 5000
    });
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers() {
    if (!this.socket) return;
    
    // æ¥ç¶šãƒ»åˆ‡æ–­
    this.socket.on('connect', () => {
      console.log('WebSocket connected');
    });
    
    this.socket.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason);
    });
    
    // çŠ¶æ…‹æ›´æ–°
    this.socket.on('status_update', (status: DetectionStatus) => {
      this.statusUpdateCallbacks.forEach(callback => callback(status));
    });
    
    // éŸ³å£°ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°
    this.socket.on('audio_stream', async (data: AudioStreamData) => {
      try {
        await this.audioManager.playAudioData(data.audio_data, data.metadata);
      } catch (error) {
        console.error('Audio playback failed:', error);
        this.notifyAudioPlaybackStatus(data.metadata.audio_id, 'error');
      }
    });
  }
  
  public onStatusUpdate(callback: (status: DetectionStatus) => void) {
    this.statusUpdateCallbacks.push(callback);
    return () => {
      const index = this.statusUpdateCallbacks.indexOf(callback);
      if (index > -1) {
        this.statusUpdateCallbacks.splice(index, 1);
      }
    };
  }
  
  public notifyAudioPlaybackStatus(audioId: string, status: 'playing' | 'finished' | 'error') {
    if (this.socket) {
      this.socket.emit('audio_playback_status', {
        status,
        audio_id: audioId
      });
    }
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export const websocketManager = new WebSocketManager();
```

==== Reactçµ±åˆä¾‹
```typescript
import { useEffect, useState } from 'react';
import { websocketManager, DetectionStatus } from '../utils/websocket';

export const MonitorView = () => {
  const [status, setStatus] = useState<DetectionStatus>({
    personDetected: false,
    smartphoneDetected: false,
    absenceTime: 0,
    smartphoneUseTime: 0
  });
  
  useEffect(() => {
    // WebSocketåˆæœŸåŒ–
    websocketManager.initialize();
    
    // çŠ¶æ…‹æ›´æ–°ã®ãƒªã‚¹ãƒŠãƒ¼è¨­å®š
    const unsubscribe = websocketManager.onStatusUpdate((newStatus) => {
      setStatus(newStatus);
    });
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    return () => {
      unsubscribe();
    };
  }, []);
  
  return (
    <div className="monitor-view">
      <div className="status-display">
        <p>åœ¨å¸­çŠ¶æ…‹: {status.personDetected ? 'åœ¨å¸­' : 'ä¸åœ¨'}</p>
        <p>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³: {status.smartphoneDetected ? 'ä½¿ç”¨ä¸­' : 'æœªä½¿ç”¨'}</p>
        <p>ä¸åœ¨æ™‚é–“: {status.absenceTime}ç§’</p>
      </div>
    </div>
  );
};
```

=== ğŸµ éŸ³å£°ç®¡ç†å®Ÿè£…

==== AudioManagerã‚¯ãƒ©ã‚¹
```typescript
class AudioManager {
  private audioContext: AudioContext | null = null;
  private currentSource: AudioBufferSourceNode | null = null;
  private isPlaying = false;
  
  constructor() {
    this.initializeAudioContext();
  }
  
  private initializeAudioContext() {
    try {
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (AudioContextClass) {
        this.audioContext = new AudioContextClass();
      }
    } catch (error) {
      console.error('AudioContext initialization failed:', error);
    }
  }
  
  async playAudioData(base64Data: string, metadata: any): Promise<void> {
    if (!this.audioContext) return;
    
    try {
      // AudioContextã‚’æœ‰åŠ¹åŒ–
      if (this.audioContext.state === 'suspended') {
        await this.audioContext.resume();
      }
      
      // Base64ãƒ‡ã‚³ãƒ¼ãƒ‰
      const binaryString = atob(base64Data);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      
      // AudioBufferã«å¤‰æ›
      const audioBuffer = await this.audioContext.decodeAudioData(bytes.buffer);
      
      // å†ç”Ÿ
      await this.playAudioBuffer(audioBuffer, metadata);
      
    } catch (error) {
      console.error('Audio playback error:', error);
      throw error;
    }
  }
  
  private async playAudioBuffer(audioBuffer: AudioBuffer, metadata: any) {
    if (!this.audioContext) return;
    
    // ç¾åœ¨ã®å†ç”Ÿã‚’åœæ­¢
    if (this.currentSource) {
      this.currentSource.stop();
    }
    
    // æ–°ã—ã„SourceNodeã‚’ä½œæˆ
    this.currentSource = this.audioContext.createBufferSource();
    this.currentSource.buffer = audioBuffer;
    this.currentSource.connect(this.audioContext.destination);
    
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
    this.currentSource.onended = () => {
      this.isPlaying = false;
      this.currentSource = null;
      websocketManager.notifyAudioPlaybackStatus(metadata.audio_id, 'finished');
    };
    
    // å†ç”Ÿé–‹å§‹
    this.isPlaying = true;
    this.currentSource.start();
    websocketManager.notifyAudioPlaybackStatus(metadata.audio_id, 'playing');
  }
}
```

== ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

=== ğŸ”¬ å˜ä½“ãƒ†ã‚¹ãƒˆ

==== WebSocketã‚¤ãƒ™ãƒ³ãƒˆãƒ†ã‚¹ãƒˆ
```javascript
// Jest + Socket.IO ãƒ†ã‚¹ãƒˆä¾‹
describe('WebSocket Events', () => {
  let clientSocket;
  let serverSocket;
  
  beforeEach((done) => {
    // ãƒ†ã‚¹ãƒˆç”¨ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
    clientSocket = io('http://localhost:8000');
    clientSocket.on('connect', done);
  });
  
  afterEach(() => {
    clientSocket.close();
  });
  
  test('should receive status_update events', (done) => {
    clientSocket.on('status_update', (data) => {
      expect(data).toHaveProperty('personDetected');
      expect(data).toHaveProperty('smartphoneDetected');
      done();
    });
    
    // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿é€ä¿¡
    clientSocket.emit('test_trigger_status');
  });
  
  test('should handle audio_playback_status correctly', (done) => {
    const testAudioId = 'test_audio_123';
    
    clientSocket.emit('audio_playback_status', {
      status: 'playing',
      audio_id: testAudioId
    });
    
    setTimeout(() => {
      // ã‚µãƒ¼ãƒãƒ¼å´ã§ã®å‡¦ç†ç¢ºèª
      done();
    }, 100);
  });
});
```

=== ğŸ”— çµ±åˆãƒ†ã‚¹ãƒˆ

==== ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰é€šä¿¡ãƒ†ã‚¹ãƒˆ
```typescript
describe('WebSocket Integration', () => {
  test('full communication flow', async () => {
    const websocketManager = new WebSocketManager();
    await websocketManager.initialize();
    
    // çŠ¶æ…‹æ›´æ–°ã®å—ä¿¡ãƒ†ã‚¹ãƒˆ
    const statusPromise = new Promise<DetectionStatus>((resolve) => {
      websocketManager.onStatusUpdate(resolve);
    });
    
    const status = await statusPromise;
    expect(status).toBeDefined();
    expect(typeof status.personDetected).toBe('boolean');
  });
});
```

== ğŸ“š ã‚¨ãƒ©ãƒ¼å¯¾å¿œã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

=== ğŸ”§ ä¸€èˆ¬çš„ãªå•é¡Œã¨è§£æ±ºæ–¹æ³•

[cols="2,3,3", options="header"]
|===
|å•é¡Œ |åŸå›  |è§£æ±ºæ–¹æ³•
|**æ¥ç¶šãŒç¢ºç«‹ã•ã‚Œãªã„** |ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å•é¡Œã€CORSè¨­å®š |ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç¢ºèªã€CORSè¨­å®šç¢ºèª
|**éŸ³å£°ãŒå†ç”Ÿã•ã‚Œãªã„** |AudioContextæœªåˆæœŸåŒ–ã€ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶é™ |ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«AudioContextåˆæœŸåŒ–
|**ãƒ‡ãƒ¼ã‚¿ãŒå—ä¿¡ã•ã‚Œãªã„** |ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼æœªè¨­å®š |ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®šç¢ºèª
|**é »ç¹ãªåˆ‡æ–­** |ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä¸å®‰å®šã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ |å†æ¥ç¶šæˆ¦ç•¥ã®å®Ÿè£…ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆèª¿æ•´
|===

=== ğŸ“Š ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ­ã‚°å‡ºåŠ›

```typescript
// ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ç”¨ã®è©³ç´°ãƒ­ã‚°
class WebSocketDebugger {
  private debug = process.env.NODE_ENV === 'development';
  
  logEvent(eventName: string, data?: any) {
    if (this.debug) {
      console.log(`[WebSocket] ${eventName}:`, data);
    }
  }
  
  logMetrics() {
    if (this.debug) {
      console.table({
        connectionStatus: this.socket?.connected,
        messagesSent: this.messagesSent,
        messagesReceived: this.messagesReceived,
        averageLatency: this.averageLatency
      });
    }
  }
}
```

== ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

=== ğŸ“Š ç›£è¦–é …ç›®

[cols="2,2,2,2", options="header"]
|===
|ãƒ¡ãƒˆãƒªã‚¯ã‚¹ |ç›®æ¨™å€¤ |è­¦å‘Šå€¤ |æ¸¬å®šæ–¹æ³•
|**æ¥ç¶šãƒ¬ã‚¤ãƒ†ãƒ³ã‚·** |<100ms |>500ms |ping/pongæ¸¬å®š
|**ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…ä¿¡ãƒ¬ãƒ¼ãƒˆ** |30FPS |<15FPS |ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—å·®åˆ†
|**éŸ³å£°ãƒãƒƒãƒ•ã‚¡ä¸è¶³** |0% |>5% |å†ç”Ÿã‚¨ãƒ©ãƒ¼ç‡
|**å†æ¥ç¶šå›æ•°** |<1/hour |>5/hour |æ¥ç¶šå±¥æ­´
|===

=== ğŸ“ˆ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–

```typescript
interface PerformanceMetrics {
  latency: number[];
  messageRate: number;
  errorRate: number;
  connectionUptime: number;
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    latency: [],
    messageRate: 0,
    errorRate: 0,
    connectionUptime: 0
  };
  
  measureLatency() {
    const start = performance.now();
    this.socket?.emit('ping', start);
    
    this.socket?.on('pong', (timestamp: number) => {
      const latency = performance.now() - timestamp;
      this.metrics.latency.push(latency);
      
      // ç›´è¿‘100ä»¶ã®å¹³å‡ã‚’ä¿æŒ
      if (this.metrics.latency.length > 100) {
        this.metrics.latency.shift();
      }
    });
  }
}
```

== ğŸ“š é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ»ãƒªã‚½ãƒ¼ã‚¹

=== ğŸ“– å‚ç…§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

* **<<rest-api-reference>>**: REST APIä»•æ§˜ï¼ˆWebSocketè£œå®Œï¼‰
* **<<communication-system>>**: é€šä¿¡ãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ è©³ç´°
* **<<development-guide>>**: é–‹ç™ºç’°å¢ƒã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹
* **<<performance-optimization>>**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–æŠ€è¡“

=== ğŸ”— å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹

* **Socket.IO**: https://socket.io/docs/v4/
* **Flask-SocketIO**: https://flask-socketio.readthedocs.io/
* **Web Audio API**: https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
* **WebSocket Protocol**: https://tools.ietf.org/html/rfc6455

=== ğŸ› ï¸ é–‹ç™ºãƒ„ãƒ¼ãƒ«

```bash
# WebSocketãƒ†ã‚¹ãƒˆãƒ„ãƒ¼ãƒ«
npm install -g wscat
wscat -c ws://localhost:8000/socket.io/?EIO=4&transport=websocket

# Socket.IOã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ†ã‚¹ãƒˆ
npm install socket.io-client
```

---

**ğŸ“ Contact**: team@kanshichan.dev +
**ğŸ”— Repository**: https://github.com/kanshichan/backend +
**ğŸ“… Last Updated**: {docdate} +
**ğŸ“ Document Version**: {revnumber} 