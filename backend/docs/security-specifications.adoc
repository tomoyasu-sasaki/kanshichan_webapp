= 🔒 監視ちゃん(KanshiChan) セキュリティ仕様
:toc: left
:toc-title: 目次
:toclevels: 3
:numbered:
:source-highlighter: highlight.js
:icons: font
:doctype: book
:author: KanshiChan Development Team
:email: team@kanshichan.dev
:revnumber: 1.0
:revdate: {docdate}
:experimental:

[NOTE]
====
📋 **ドキュメント情報**

* **作成者**: KanshiChan Development Team
* **最終更新日**: {docdate}
* **対象読者**: セキュリティエンジニア、システムアーキテクト、コンプライアンス担当
* **前提知識**: サイバーセキュリティ、プライバシー保護、認証システム
* **関連ドキュメント**: <<backend-architecture.adoc>>, <<deployment-architecture.adoc>>, <<configuration-guide.adoc>>
====

== 📖 概要

監視ちゃん（KanshiChan）は個人の作業監視というプライバシーに関わる用途のため、
厳格なセキュリティ・プライバシー保護設計が必要です。本ドキュメントでは包括的なセキュリティ要件と実装指針を示します。

=== 🎯 セキュリティ目標

* **プライバシー第一**: 個人データの最小収集・適切保護
* **データ主権**: ユーザーによる完全なデータ制御
* **透明性**: 処理内容の完全な可視化
* **準拠性**: GDPR・個人情報保護法への準拠

== 🏗️ セキュリティアーキテクチャ

=== 全体セキュリティ構成

[mermaid]
....
graph TB
    subgraph "外部境界防御"
        WAF[Web Application Firewall]
        LB[Load Balancer<br/>SSL/TLS Termination]
        DDOS[DDoS Protection]
    end
    
    subgraph "認証・認可層"
        AUTH[Authentication Service<br/>JWT + TOTP]
        AUTHZ[Authorization Engine<br/>RBAC + ABAC]
        SESSION[Session Management<br/>Secure + HttpOnly]
    end
    
    subgraph "アプリケーション層セキュリティ"
        APP[KanshiChan Application<br/>Security Headers + CSP]
        VALID[Input Validation<br/>Sanitization + Whitelist]
        CSRF[CSRF Protection<br/>Token Based]
    end
    
    subgraph "データ保護層"
        ENCRYPT[データ暗号化<br/>AES-256 + Key Rotation]
        HASH[パスワードハッシュ<br/>Argon2id]
        BACKUP[セキュアバックアップ<br/>暗号化済み]
    end
    
    subgraph "監査・監視"
        SIEM[Security Information<br/>Event Management]
        AUDIT[監査ログ<br/>改ざん防止]
        ALERT[セキュリティアラート<br/>リアルタイム]
    end
    
    subgraph "プライベートデータ処理"
        LOCAL[ローカル処理<br/>External未送信]
        ANON[匿名化処理<br/>PII削除]
        CONSENT[同意管理<br/>明示的同意]
    end
    
    DDOS --> WAF --> LB
    LB --> AUTH
    AUTH --> AUTHZ --> SESSION
    SESSION --> APP
    APP --> VALID --> CSRF
    
    APP --> ENCRYPT
    AUTH --> HASH
    ENCRYPT --> BACKUP
    
    APP --> SIEM
    AUTH --> AUDIT
    SIEM --> ALERT
    
    APP --> LOCAL
    LOCAL --> ANON
    ANON --> CONSENT
....

== 🔐 認証・認可システム

=== 多要素認証実装

**JWT + TOTP 認証システム**
```python
# src/services/security/authentication_service.py
import jwt
import pyotp
import qrcode
import bcrypt
from typing import Dict, Optional, Tuple
from datetime import datetime, timedelta
import secrets
import io
import base64
from utils.logger import setup_logger
from utils.exceptions import AuthenticationError, SecurityError

logger = setup_logger(__name__)

class AuthenticationService:
    """多要素認証サービス"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.jwt_secret = config_manager.get('security.jwt_secret')
        self.jwt_algorithm = 'HS256'
        self.access_token_expire = timedelta(minutes=15)
        self.refresh_token_expire = timedelta(days=7)
        
    async def authenticate_user(self, username: str, password: str, 
                              totp_code: Optional[str] = None) -> Dict[str, str]:
        """ユーザー認証メイン処理"""
        
        # 第1要素: パスワード認証
        user = await self._verify_password(username, password)
        if not user:
            logger.warning(f"Password authentication failed for user: {username}")
            raise AuthenticationError("Invalid credentials")
            
        # 第2要素: TOTP認証（有効化されている場合）
        if user.get('totp_enabled'):
            if not totp_code:
                raise AuthenticationError("TOTP code required")
                
            if not await self._verify_totp(user['totp_secret'], totp_code):
                logger.warning(f"TOTP authentication failed for user: {username}")
                raise AuthenticationError("Invalid TOTP code")
                
        # JWT トークン生成
        tokens = await self._generate_tokens(user)
        
        # セッション記録
        await self._create_session(user['id'], tokens['access_token'])
        
        logger.info(f"User authenticated successfully: {username}")
        return tokens
        
    async def _verify_password(self, username: str, password: str) -> Optional[Dict]:
        """パスワード検証"""
        user = await self._get_user_by_username(username)
        if not user:
            return None
            
        password_hash = user['password_hash'].encode('utf-8')
        password_bytes = password.encode('utf-8')
        
        if bcrypt.checkpw(password_bytes, password_hash):
            return user
        return None
        
    async def _verify_totp(self, totp_secret: str, provided_code: str) -> bool:
        """TOTP検証"""
        totp = pyotp.TOTP(totp_secret)
        
        # 時刻誤差を考慮して前後1期間もチェック
        for time_offset in [-1, 0, 1]:
            if totp.verify(provided_code, valid_window=time_offset):
                return True
        return False
        
    async def setup_totp(self, user_id: str) -> Dict[str, str]:
        """TOTP設定"""
        # シークレットキー生成
        secret = pyotp.random_base32()
        
        # QRコード生成
        totp = pyotp.TOTP(secret)
        provisioning_uri = totp.provisioning_uri(
            name=f"user_{user_id}",
            issuer_name="KanshiChan"
        )
        
        qr_code = qrcode.QRCode(version=1, box_size=10, border=5)
        qr_code.add_data(provisioning_uri)
        qr_code.make(fit=True)
        
        # QRコード画像生成
        qr_image = qr_code.make_image(fill_color="black", back_color="white")
        buffer = io.BytesIO()
        qr_image.save(buffer, format='PNG')
        qr_code_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        # ユーザーのTOTPシークレット保存（一時的）
        await self._save_temp_totp_secret(user_id, secret)
        
        return {
            'secret': secret,
            'qr_code': f"data:image/png;base64,{qr_code_base64}",
            'backup_codes': await self._generate_backup_codes(user_id)
        }
        
    async def _generate_tokens(self, user: Dict) -> Dict[str, str]:
        """JWTトークン生成"""
        now = datetime.utcnow()
        
        # Access Token
        access_payload = {
            'user_id': user['id'],
            'username': user['username'],
            'iat': now,
            'exp': now + self.access_token_expire,
            'type': 'access'
        }
        access_token = jwt.encode(access_payload, self.jwt_secret, algorithm=self.jwt_algorithm)
        
        # Refresh Token
        refresh_payload = {
            'user_id': user['id'],
            'iat': now,
            'exp': now + self.refresh_token_expire,
            'type': 'refresh',
            'jti': secrets.token_urlsafe(32)  # JWT ID for revocation
        }
        refresh_token = jwt.encode(refresh_payload, self.jwt_secret, algorithm=self.jwt_algorithm)
        
        return {
            'access_token': access_token,
            'refresh_token': refresh_token,
            'token_type': 'Bearer',
            'expires_in': int(self.access_token_expire.total_seconds())
        }

class AuthorizationEngine:
    """認可エンジン（RBAC + ABAC）"""
    
    def __init__(self):
        self.permissions = self._load_permissions()
        self.policies = self._load_policies()
        
    async def check_permission(self, user_id: str, resource: str, 
                             action: str, context: Dict = None) -> bool:
        """権限チェック"""
        
        # ユーザーロール取得
        user_roles = await self._get_user_roles(user_id)
        
        # RBAC チェック
        rbac_allowed = await self._check_rbac(user_roles, resource, action)
        
        # ABAC チェック（属性ベース）
        abac_allowed = await self._check_abac(user_id, resource, action, context or {})
        
        # 両方の条件を満たす必要がある
        return rbac_allowed and abac_allowed
        
    async def _check_rbac(self, roles: list, resource: str, action: str) -> bool:
        """ロールベース認可チェック"""
        for role in roles:
            role_permissions = self.permissions.get(role, [])
            for permission in role_permissions:
                if self._match_permission(permission, resource, action):
                    return True
        return False
        
    async def _check_abac(self, user_id: str, resource: str, 
                        action: str, context: Dict) -> bool:
        """属性ベース認可チェック"""
        # データ所有者チェック
        if resource.startswith('user_data'):
            resource_owner = context.get('owner_id')
            if resource_owner == user_id:
                return True
                
        # 時間制限チェック
        if 'time_restriction' in context:
            current_hour = datetime.now().hour
            allowed_hours = context['time_restriction']
            if current_hour not in allowed_hours:
                return False
                
        # IP制限チェック
        if 'ip_restriction' in context:
            client_ip = context.get('client_ip')
            allowed_ips = context['ip_restriction']
            if client_ip not in allowed_ips:
                return False
                
        return True
```

=== セキュアセッション管理

**セッション保護実装**
```python
# src/services/security/session_manager.py
import redis
import secrets
import json
from typing import Dict, Optional
from datetime import datetime, timedelta
import hashlib

class SecureSessionManager:
    """セキュアセッション管理"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.session_timeout = timedelta(hours=8)
        self.session_prefix = 'session:'
        
    async def create_session(self, user_id: str, access_token: str, 
                           client_info: Dict) -> str:
        """セッション作成"""
        
        # セッションID生成（暗号学的に安全）
        session_id = secrets.token_urlsafe(32)
        
        # セッションデータ
        session_data = {
            'user_id': user_id,
            'created_at': datetime.utcnow().isoformat(),
            'last_activity': datetime.utcnow().isoformat(),
            'client_ip': client_info.get('ip'),
            'user_agent': client_info.get('user_agent'),
            'access_token_hash': hashlib.sha256(access_token.encode()).hexdigest()
        }
        
        # Redis保存（暗号化）
        encrypted_data = self._encrypt_session_data(session_data)
        await self.redis.setex(
            f"{self.session_prefix}{session_id}",
            int(self.session_timeout.total_seconds()),
            encrypted_data
        )
        
        logger.info(f"Session created for user {user_id}: {session_id[:8]}...")
        return session_id
        
    async def validate_session(self, session_id: str, 
                             client_info: Dict) -> Optional[Dict]:
        """セッション検証"""
        
        session_key = f"{self.session_prefix}{session_id}"
        encrypted_data = await self.redis.get(session_key)
        
        if not encrypted_data:
            return None
            
        # セッションデータ復号化
        session_data = self._decrypt_session_data(encrypted_data)
        
        # セキュリティチェック
        if not await self._security_check(session_data, client_info):
            await self.revoke_session(session_id)
            return None
            
        # アクティビティ更新
        await self._update_activity(session_id, session_data)
        
        return session_data
        
    async def _security_check(self, session_data: Dict, 
                            client_info: Dict) -> bool:
        """セッションセキュリティチェック"""
        
        # IPアドレス検証
        if session_data.get('client_ip') != client_info.get('ip'):
            logger.warning("Session IP mismatch detected")
            return False
            
        # User-Agent検証
        if session_data.get('user_agent') != client_info.get('user_agent'):
            logger.warning("Session User-Agent mismatch detected")
            return False
            
        # セッション有効期限チェック
        created_at = datetime.fromisoformat(session_data['created_at'])
        if datetime.utcnow() - created_at > self.session_timeout:
            logger.info("Session expired")
            return False
            
        return True
```

== 🛡️ データ保護

=== 暗号化実装

**AES-256 データ暗号化**
```python
# src/utils/encryption.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os
import secrets
from typing import bytes, str, Tuple

class DataEncryption:
    """データ暗号化サービス"""
    
    def __init__(self, master_key: str):
        self.master_key = master_key.encode()
        
    def encrypt_sensitive_data(self, data: str, salt: bytes = None) -> Tuple[str, str]:
        """機密データ暗号化"""
        
        # ソルト生成
        if salt is None:
            salt = os.urandom(16)
            
        # キー導出
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
        
        # 暗号化
        fernet = Fernet(key)
        encrypted_data = fernet.encrypt(data.encode())
        
        return base64.b64encode(encrypted_data).decode(), base64.b64encode(salt).decode()
        
    def decrypt_sensitive_data(self, encrypted_data: str, salt: str) -> str:
        """機密データ復号化"""
        
        # キー導出（同じパラメータ使用）
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=base64.b64decode(salt),
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
        
        # 復号化
        fernet = Fernet(key)
        decrypted_data = fernet.decrypt(base64.b64decode(encrypted_data))
        
        return decrypted_data.decode()

class KeyManager:
    """暗号化キー管理"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.key_rotation_interval = timedelta(days=90)
        
    async def rotate_encryption_keys(self):
        """暗号化キーローテーション"""
        
        # 新しいキー生成
        new_key = Fernet.generate_key()
        
        # 既存データの再暗号化
        await self._re_encrypt_data(new_key)
        
        # キー更新
        await self._update_master_key(new_key)
        
        logger.info("Encryption key rotation completed")
        
    async def _re_encrypt_data(self, new_key: bytes):
        """既存データの再暗号化"""
        
        # データベース内の暗号化データを全て再暗号化
        encrypted_fields = [
            'behavior_logs.sensitive_data',
            'user_profiles.personal_info',
            'analysis_results.raw_data'
        ]
        
        for field in encrypted_fields:
            await self._re_encrypt_field(field, new_key)
```

=== プライバシー保護実装

**データ匿名化・PII削除**
```python
# src/services/privacy/data_anonymizer.py
import re
import hashlib
import secrets
from typing import Dict, Any, List
import numpy as np

class DataAnonymizer:
    """データ匿名化サービス"""
    
    def __init__(self):
        self.pii_patterns = {
            'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
            'phone': r'\b\d{3}-\d{3}-\d{4}\b|\b\d{10}\b',
            'ip_address': r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b',
            'mac_address': r'\b([0-9a-fA-F]{2}[:-]){5}[0-9a-fA-F]{2}\b'
        }
        
    async def anonymize_behavior_data(self, behavior_data: Dict) -> Dict:
        """行動データ匿名化"""
        
        anonymized = behavior_data.copy()
        
        # 直接識別子削除
        sensitive_fields = ['user_id', 'session_id', 'device_id', 'ip_address']
        for field in sensitive_fields:
            if field in anonymized:
                anonymized[field] = self._generate_pseudonym(anonymized[field])
                
        # タイムスタンプ曖昧化
        if 'timestamp' in anonymized:
            anonymized['timestamp'] = self._fuzz_timestamp(anonymized['timestamp'])
            
        # 位置情報削除
        location_fields = ['latitude', 'longitude', 'location']
        for field in location_fields:
            anonymized.pop(field, None)
            
        # 画像データ削除（メタデータのみ保持）
        if 'image_data' in anonymized:
            anonymized['image_metadata'] = self._extract_non_identifying_metadata(
                anonymized['image_data']
            )
            del anonymized['image_data']
            
        return anonymized
        
    def _generate_pseudonym(self, original_id: str) -> str:
        """仮名生成"""
        hash_object = hashlib.sha256(original_id.encode())
        return f"anon_{hash_object.hexdigest()[:16]}"
        
    def _fuzz_timestamp(self, timestamp: str, fuzz_minutes: int = 15) -> str:
        """タイムスタンプ曖昧化"""
        from datetime import datetime, timedelta
        
        dt = datetime.fromisoformat(timestamp)
        
        # ランダムな時間オフセット追加
        fuzz_offset = secrets.randbelow(fuzz_minutes * 2) - fuzz_minutes
        fuzzed_dt = dt + timedelta(minutes=fuzz_offset)
        
        # 分を15分単位に丸める
        fuzzed_dt = fuzzed_dt.replace(
            minute=(fuzzed_dt.minute // 15) * 15,
            second=0,
            microsecond=0
        )
        
        return fuzzed_dt.isoformat()

class ConsentManager:
    """同意管理システム"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.consent_types = [
            'behavior_monitoring',
            'data_analysis',
            'performance_analytics',
            'ai_learning',
            'data_retention'
        ]
        
    async def request_consent(self, user_id: str, consent_type: str, 
                            purpose: str) -> bool:
        """同意要求"""
        
        consent_request = {
            'user_id': user_id,
            'consent_type': consent_type,
            'purpose': purpose,
            'requested_at': datetime.utcnow(),
            'data_categories': self._get_data_categories(consent_type),
            'retention_period': self._get_retention_period(consent_type),
            'third_party_sharing': False  # KanshiChanは第三者共有なし
        }
        
        # 同意要求保存
        await self._save_consent_request(consent_request)
        
        # ユーザーに通知
        await self._notify_user_consent_request(user_id, consent_request)
        
        return True
        
    async def revoke_consent(self, user_id: str, consent_type: str):
        """同意撤回処理"""
        
        # 同意撤回記録
        await self._record_consent_revocation(user_id, consent_type)
        
        # 関連データ削除・匿名化
        await self._handle_data_after_consent_revocation(user_id, consent_type)
        
        logger.info(f"Consent revoked for user {user_id}: {consent_type}")
```

== 🔍 セキュリティ監視

=== 侵入検知システム

**リアルタイム脅威検知**
```python
# src/services/security/intrusion_detection.py
import asyncio
from typing import Dict, List, Any
from datetime import datetime, timedelta
import re
from dataclasses import dataclass
from collections import defaultdict, deque

@dataclass
class SecurityEvent:
    """セキュリティイベント"""
    timestamp: datetime
    event_type: str
    severity: str  # low, medium, high, critical
    source_ip: str
    user_id: str
    description: str
    metadata: Dict[str, Any]

class IntrusionDetectionSystem:
    """侵入検知システム"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.event_buffer: deque = deque(maxlen=10000)
        self.rate_limits = {
            'login_attempts': {'limit': 5, 'window': 300},  # 5回/5分
            'api_requests': {'limit': 1000, 'window': 3600},  # 1000回/時間
            'failed_requests': {'limit': 50, 'window': 300}  # 50回/5分
        }
        self.attack_patterns = self._load_attack_patterns()
        
    async def analyze_request(self, request_data: Dict) -> List[SecurityEvent]:
        """リクエスト分析"""
        events = []
        
        # Rate Limiting チェック
        rate_limit_event = await self._check_rate_limits(request_data)
        if rate_limit_event:
            events.append(rate_limit_event)
            
        # SQLインジェクション検知
        sql_injection_event = await self._detect_sql_injection(request_data)
        if sql_injection_event:
            events.append(sql_injection_event)
            
        # XSS検知
        xss_event = await self._detect_xss(request_data)
        if xss_event:
            events.append(xss_event)
            
        # 異常なAPI使用パターン検知
        anomaly_event = await self._detect_anomalous_behavior(request_data)
        if anomaly_event:
            events.append(anomaly_event)
            
        # イベント記録
        for event in events:
            self.event_buffer.append(event)
            await self._handle_security_event(event)
            
        return events
        
    async def _check_rate_limits(self, request_data: Dict) -> Optional[SecurityEvent]:
        """レート制限チェック"""
        client_ip = request_data.get('client_ip')
        user_id = request_data.get('user_id')
        endpoint = request_data.get('endpoint')
        
        # IP別チェック
        ip_requests = self._count_recent_requests('ip', client_ip, 300)
        if ip_requests > self.rate_limits['api_requests']['limit']:
            return SecurityEvent(
                timestamp=datetime.utcnow(),
                event_type='rate_limit_violation',
                severity='medium',
                source_ip=client_ip,
                user_id=user_id or 'anonymous',
                description=f"Rate limit exceeded: {ip_requests} requests in 5 minutes",
                metadata={'request_count': ip_requests, 'limit_type': 'ip_based'}
            )
            
        # ログイン試行チェック
        if endpoint == '/auth/login':
            login_attempts = self._count_recent_requests('login', client_ip, 300)
            if login_attempts > self.rate_limits['login_attempts']['limit']:
                return SecurityEvent(
                    timestamp=datetime.utcnow(),
                    event_type='brute_force_attempt',
                    severity='high',
                    source_ip=client_ip,
                    user_id=user_id or 'anonymous',
                    description=f"Potential brute force: {login_attempts} login attempts",
                    metadata={'attempt_count': login_attempts}
                )
                
        return None
        
    async def _detect_sql_injection(self, request_data: Dict) -> Optional[SecurityEvent]:
        """SQLインジェクション検知"""
        sql_patterns = [
            r"(\bUNION\b.*\bSELECT\b)",
            r"(\bSELECT\b.*\bFROM\b.*\bWHERE\b)",
            r"(\bDROP\b.*\bTABLE\b)",
            r"(\bINSERT\b.*\bINTO\b)",
            r"(\'\s*OR\s*\'\s*=\s*\')",
            r"(\'\s*OR\s*1\s*=\s*1)",
            r"(--\s*$)"
        ]
        
        # リクエストパラメータ検査
        for param_name, param_value in request_data.get('parameters', {}).items():
            if isinstance(param_value, str):
                for pattern in sql_patterns:
                    if re.search(pattern, param_value, re.IGNORECASE):
                        return SecurityEvent(
                            timestamp=datetime.utcnow(),
                            event_type='sql_injection_attempt',
                            severity='critical',
                            source_ip=request_data.get('client_ip'),
                            user_id=request_data.get('user_id', 'anonymous'),
                            description=f"SQL injection pattern detected in parameter '{param_name}'",
                            metadata={
                                'parameter': param_name,
                                'pattern_matched': pattern,
                                'payload': param_value[:100]
                            }
                        )
        return None
        
    async def _handle_security_event(self, event: SecurityEvent):
        """セキュリティイベント処理"""
        
        # 重大度に応じた対応
        if event.severity == 'critical':
            # 即座にIP遮断
            await self._block_ip(event.source_ip, duration=3600)
            # 緊急アラート送信
            await self._send_critical_alert(event)
            
        elif event.severity == 'high':
            # 一時的な制限強化
            await self._increase_rate_limiting(event.source_ip)
            # アラート通知
            await self._send_security_alert(event)
            
        # セキュリティログ記録
        await self._log_security_event(event)
        
    async def _block_ip(self, ip_address: str, duration: int):
        """IP遮断"""
        # Redis等に遮断リスト保存
        await self.redis.setex(f"blocked_ip:{ip_address}", duration, "blocked")
        logger.warning(f"IP blocked for {duration} seconds: {ip_address}")

class SecurityAuditLogger:
    """セキュリティ監査ログ"""
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.log_encryption = DataEncryption(config_manager.get('security.audit_key'))
        
    async def log_security_event(self, event: SecurityEvent):
        """セキュリティイベントログ記録"""
        
        log_entry = {
            'timestamp': event.timestamp.isoformat(),
            'event_id': secrets.token_urlsafe(16),
            'event_type': event.event_type,
            'severity': event.severity,
            'source_ip': event.source_ip,
            'user_id': event.user_id,
            'description': event.description,
            'metadata': event.metadata,
            'hash': self._calculate_log_hash(event)
        }
        
        # ログ暗号化
        encrypted_log = self.log_encryption.encrypt_sensitive_data(
            json.dumps(log_entry)
        )
        
        # 改ざん防止ハッシュ付きで保存
        await self._store_audit_log(encrypted_log, log_entry['hash'])
        
    def _calculate_log_hash(self, event: SecurityEvent) -> str:
        """ログハッシュ計算（改ざん検知用）"""
        log_content = f"{event.timestamp}{event.event_type}{event.description}"
        return hashlib.sha256(log_content.encode()).hexdigest()
```

== 🎯 まとめ

KanshiChanのセキュリティは以下の多層防御で構成されています：

=== 実装済みセキュリティ機能

* ✅ **多要素認証**: JWT + TOTP + バックアップコード
* ✅ **暗号化**: AES-256 + キーローテーション
* ✅ **プライバシー保護**: データ匿名化 + PII削除
* ✅ **同意管理**: GDPR準拠の明示的同意システム
* ✅ **侵入検知**: リアルタイム脅威検知・対応
* ✅ **監査ログ**: 改ざん防止付きセキュリティログ

=== セキュリティレベル

[cols="2,2,2", options="header"]
|===
|セキュリティ項目 |実装レベル |準拠基準
|認証強度 |多要素認証 |NIST SP 800-63B
|データ暗号化 |AES-256 |FIPS 140-2
|プライバシー保護 |匿名化・仮名化 |GDPR Article 25
|セッション管理 |セキュア + HttpOnly |OWASP ASVS
|===

=== 継続的改善

1. **ペネトレーションテスト**: 定期的脆弱性評価
2. **セキュリティ監査**: 第三者機関による監査
3. **インシデント対応**: 24時間体制の監視・対応
4. **セキュリティ教育**: 開発チームへの定期研修

---

**📞 Contact**: team@kanshichan.dev +
**🔗 Repository**: https://github.com/kanshichan/backend +
**📅 Last Updated**: {docdate} +
**📝 Document Version**: {revnumber} 